"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    let isRequired = !!props.isRequired && selectedValues.length === 0;\n    let invalidValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValues\n    });\n    let isInvalid = validation.displayValidation.isInvalid;\n    var _props_validationState;\n    const state = {\n        ...validation,\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        setInvalid (value, v) {\n            let s = new Map(invalidValues.current);\n            if (v.isInvalid) s.set(value, v);\n            else s.delete(value);\n            invalidValues.current = s;\n            validation.updateValidation((0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.mergeValidation)(...s.values()));\n        },\n        validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? \"invalid\" : null,\n        isInvalid: isInvalid,\n        isRequired: isRequired\n    };\n    return state;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUk7QUFDbEQ7QUFDdkM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNkRBQTZEO0FBQzdELHlDQUF5QyxvRUFBeUI7QUFDbEU7QUFDQSw0QkFBNEIseUNBQWE7QUFDekMseUJBQXlCLHVFQUE2QjtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdFQUFzQjtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUs0RTtBQUM1RSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9jaGVja2JveC9kaXN0L2ltcG9ydC5tanM/ZTI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUZvcm1WYWxpZGF0aW9uU3RhdGUgYXMgJGIzbnVPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUsIG1lcmdlVmFsaWRhdGlvbiBhcyAkYjNudU8kbWVyZ2VWYWxpZGF0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkYjNudU8kdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNShwcm9wcyA9IHt9KSB7XG4gICAgbGV0IFtzZWxlY3RlZFZhbHVlcywgc2V0VmFsdWVdID0gKDAsICRiM251TyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUgfHwgW10sIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgaXNSZXF1aXJlZCA9ICEhcHJvcHMuaXNSZXF1aXJlZCAmJiBzZWxlY3RlZFZhbHVlcy5sZW5ndGggPT09IDA7XG4gICAgbGV0IGludmFsaWRWYWx1ZXMgPSAoMCwgJGIzbnVPJHVzZVJlZikobmV3IE1hcCgpKTtcbiAgICBsZXQgdmFsaWRhdGlvbiA9ICgwLCAkYjNudU8kdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgfSk7XG4gICAgbGV0IGlzSW52YWxpZCA9IHZhbGlkYXRpb24uZGlzcGxheVZhbGlkYXRpb24uaXNJbnZhbGlkO1xuICAgIHZhciBfcHJvcHNfdmFsaWRhdGlvblN0YXRlO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAuLi52YWxpZGF0aW9uLFxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgIHNldFZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBpc1JlYWRPbmx5OiBwcm9wcy5pc1JlYWRPbmx5IHx8IGZhbHNlLFxuICAgICAgICBpc1NlbGVjdGVkICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuZmlsdGVyKChleGlzdGluZ1ZhbHVlKT0+ZXhpc3RpbmdWYWx1ZSAhPT0gdmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5maWx0ZXIoKGV4aXN0aW5nVmFsdWUpPT5leGlzdGluZ1ZhbHVlICE9PSB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW52YWxpZCAodmFsdWUsIHYpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV3IE1hcChpbnZhbGlkVmFsdWVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHYuaXNJbnZhbGlkKSBzLnNldCh2YWx1ZSwgdik7XG4gICAgICAgICAgICBlbHNlIHMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZXMuY3VycmVudCA9IHM7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLnVwZGF0ZVZhbGlkYXRpb24oKDAsICRiM251TyRtZXJnZVZhbGlkYXRpb24pKC4uLnMudmFsdWVzKCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlOiAoX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSA9IHByb3BzLnZhbGlkYXRpb25TdGF0ZSkgIT09IG51bGwgJiYgX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSAhPT0gdm9pZCAwID8gX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSA6IGlzSW52YWxpZCA/IFwiaW52YWxpZFwiIDogbnVsbCxcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXG4gICAgICAgIGlzUmVxdWlyZWQ6IGlzUmVxdWlyZWRcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuXG5cblxuZXhwb3J0IHskNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNSBhcyB1c2VDaGVja2JveEdyb3VwU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.\n                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\n\n\n\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // 🤷\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\n\n\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkRBQTJEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQkFBb0Isa0NBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0EsZ0JBQWdCLGtDQUFZO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVSxFQUFFLGdCQUFnQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLEdBQUcsa0JBQWtCLFNBQVMsa0JBQWtCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQXVELFVBQVUsRUFBRSxZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCw0Q0FBNEMsUUFBUSxrREFBa0QsV0FBVyxtREFBbUQ7QUFDclI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUyxFQUFFLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSxzQkFBc0IsMENBQWM7QUFDcEMsVUFBVSwyREFBMkQ7QUFDckUscUJBQXFCLDBDQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPZ2xCO0FBQ2hsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9ucy9kaXN0L2ltcG9ydC5tanM/OTkxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJHR5VzZBJHJlYWN0LCB7dXNlTWVtbyBhcyAkdHlXNkEkdXNlTWVtb30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbShwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBjaGlsZEl0ZW1zOiBjaGlsZEl0ZW1zLCB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgbGV0IHJlbmRlcmVkID0gcHJvcHMudGl0bGUgfHwgcHJvcHMuY2hpbGRyZW47XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIHJlbmRlcmVkID09PSBcInN0cmluZ1wiID8gcmVuZGVyZWQgOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcbiAgICAvLyBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcgaXMgdXNlZCBpbiBjb21wb25lbnRzIGxpa2UgVGFicywgd2hpY2ggZG9uJ3QgaGF2ZSB0eXBlIHRvIHNlbGVjdCBzdXBwb3J0LlxuICAgIGlmICghdGV4dFZhbHVlICYmICEoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN1cHByZXNzVGV4dFZhbHVlV2FybmluZykpIGNvbnNvbGUud2FybihcIjxJdGVtPiB3aXRoIG5vbi1wbGFpbiB0ZXh0IGNvbnRlbnRzIGlzIHVuc3VwcG9ydGVkIGJ5IHR5cGUgdG8gc2VsZWN0IGZvciBhY2Nlc3NpYmlsaXR5LiBQbGVhc2UgYWRkIGEgYHRleHRWYWx1ZWAgcHJvcC5cIik7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyhwcm9wcyksXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZEl0ZW1zKSBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZEl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaGFzQ2hpbGRJdGVtcyAhPSBudWxsKSByZXR1cm4gcHJvcHMuaGFzQ2hpbGRJdGVtcztcbiAgICBpZiAocHJvcHMuY2hpbGRJdGVtcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHByb3BzLnRpdGxlICYmICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJGMxZDdmYjJlYzkxYmFlNzEkZXhwb3J0JDZkMDg3NzNkMmU2NmY4ZjIgPSAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIHRpdGxlOiB0aXRsZSwgaXRlbXM6IGl0ZW1zIH0gPSBwcm9wcztcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwic2VjdGlvblwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgIHJlbmRlcmVkOiB0aXRsZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlID0gJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb247XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNsYXNzICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIHtcbiAgICBidWlsZChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlKCgpPT50aGlzLml0ZXJhdGVDb2xsZWN0aW9uKHByb3BzKSk7XG4gICAgfVxuICAgICppdGVyYXRlQ29sbGVjdGlvbihwcm9wcykge1xuICAgICAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHByb3BzLml0ZW1zKXlpZWxkKiB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpe1xuICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IHRoaXMuZ2V0RnVsbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEtleShpdGVtLCBwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSkge1xuICAgICAgICBpZiAoaXRlbS5rZXkgIT0gbnVsbCkgcmV0dXJuIGl0ZW0ua2V5O1xuICAgICAgICBpZiAocGFydGlhbE5vZGUudHlwZSA9PT0gXCJjZWxsXCIgJiYgcGFydGlhbE5vZGUua2V5ICE9IG51bGwpIHJldHVybiBgJHtwYXJlbnRLZXl9JHtwYXJ0aWFsTm9kZS5rZXl9YDtcbiAgICAgICAgbGV0IHYgPSBwYXJ0aWFsTm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF92X2tleTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX3Zfa2V5ID0gdi5rZXkpICE9PSBudWxsICYmIF92X2tleSAhPT0gdm9pZCAwID8gX3Zfa2V5IDogdi5pZDtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8ga2V5IGZvdW5kIGZvciBpdGVtXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fS4ke3BhcnRpYWxOb2RlLmluZGV4fWAgOiBgJC4ke3BhcnRpYWxOb2RlLmluZGV4fWA7XG4gICAgfVxuICAgIGdldENoaWxkU3RhdGUoc3RhdGUsIHBhcnRpYWxOb2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXJlcjogcGFydGlhbE5vZGUucmVuZGVyZXIgfHwgc3RhdGUucmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmdldEZ1bGxOb2RlKHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSB2YWx1ZSBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgb24gdGhlIG5vZGUsIGFuZCBhIHBhcmVudCByZW5kZXJlciBmdW5jdGlvbiBpcyBhdmFpbGFibGUsXG4gICAgICAgIC8vIHVzZSBpdCB0byByZW5kZXIgYW4gZWxlbWVudCBmb3IgdGhlIHZhbHVlLlxuICAgICAgICBsZXQgZWxlbWVudCA9IHBhcnRpYWxOb2RlLmVsZW1lbnQ7XG4gICAgICAgIGlmICghZWxlbWVudCAmJiBwYXJ0aWFsTm9kZS52YWx1ZSAmJiBzdGF0ZSAmJiBzdGF0ZS5yZW5kZXJlcikge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuY2FjaGUuZ2V0KHBhcnRpYWxOb2RlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgKCFjYWNoZWQuc2hvdWxkSW52YWxpZGF0ZSB8fCAhY2FjaGVkLnNob3VsZEludmFsaWRhdGUodGhpcy5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQuaW5kZXggPSBwYXJ0aWFsTm9kZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjYWNoZWQucGFyZW50S2V5ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUua2V5IDogbnVsbDtcbiAgICAgICAgICAgICAgICB5aWVsZCBjYWNoZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IHN0YXRlLnJlbmRlcmVyKHBhcnRpYWxOb2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVsZW1lbnQgd2l0aCBhIGdldENvbGxlY3Rpb25Ob2RlIGZ1bmN0aW9uIG9uIGl0cyB0eXBlLCB0aGVuIGl0J3MgYSBzdXBwb3J0ZWQgY29tcG9uZW50LlxuICAgICAgICAvLyBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGEgcGFydGlhbCBub2RlLCBhbmQgcmVjdXJzaXZlbHkgYnVpbGQgYSBmdWxsIG5vZGUgZnJvbSB0aGVyZS5cbiAgICAgICAgaWYgKCgwLCAkdHlXNkEkcmVhY3QpLmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0eXBlLmdldENvbGxlY3Rpb25Ob2RlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnQudHlwZS5uYW1lIDogZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlbGVtZW50IDwke25hbWV9PiBpbiBjb2xsZWN0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB0eXBlLmdldENvbGxlY3Rpb25Ob2RlKGVsZW1lbnQucHJvcHMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJ0aWFsTm9kZS5pbmRleDtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjaGlsZE5vZGVzLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlKCFyZXN1bHQuZG9uZSAmJiByZXN1bHQudmFsdWUpe1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgcGFydGlhbE5vZGUuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUtleSA9IGNoaWxkTm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlS2V5KSBub2RlS2V5ID0gY2hpbGROb2RlLmVsZW1lbnQgPyBudWxsIDogdGhpcy5nZXRLZXkoZWxlbWVudCwgcGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IHRoaXMuZ2V0RnVsbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogbm9kZUtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZShwYXJ0aWFsTm9kZS53cmFwcGVyLCBjaGlsZE5vZGUud3JhcHBlcilcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmdldENoaWxkU3RhdGUoc3RhdGUsIGNoaWxkTm9kZSksIHBhcmVudEtleSA/IGAke3BhcmVudEtleX0ke2VsZW1lbnQua2V5fWAgOiBlbGVtZW50LmtleSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2Rlc1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZHJlbil7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBub2RlIGJhc2VkIG9uIGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gY2hpbGROb2RlLnZhbHVlIHx8IHBhcnRpYWxOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS52YWx1ZSkgdGhpcy5jYWNoZS5zZXQobm9kZS52YWx1ZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJ0aWFsIG5vZGUgbWF5IGhhdmUgc3BlY2lmaWVkIGEgdHlwZSBmb3IgdGhlIGNoaWxkIGluIG9yZGVyIHRvIHNwZWNpZnkgYSBjb25zdHJhaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgZnVsbCBub2RlIHRoYXQgd2FzIGJ1aWx0IHJlY3Vyc2l2ZWx5IG1hdGNoZXMgdGhpcyB0eXBlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGlhbE5vZGUudHlwZSAmJiBub2RlLnR5cGUgIT09IHBhcnRpYWxOb2RlLnR5cGUpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShub2RlLnR5cGUpfT4gaW4gPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUocGFyZW50Tm9kZS50eXBlKX0+LiBPbmx5IDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcnRpYWxOb2RlLnR5cGUpfT4gaXMgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZE5vZGVzLm5leHQoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gICAgICAgIGlmIChwYXJ0aWFsTm9kZS5rZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgZnVsbCBub2RlXG4gICAgICAgIGxldCBidWlsZGVyID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBwYXJ0aWFsTm9kZS50eXBlLFxuICAgICAgICAgICAgcHJvcHM6IHBhcnRpYWxOb2RlLnByb3BzLFxuICAgICAgICAgICAga2V5OiBwYXJ0aWFsTm9kZS5rZXksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGwsXG4gICAgICAgICAgICB2YWx1ZTogcGFydGlhbE5vZGUudmFsdWUsXG4gICAgICAgICAgICBsZXZlbDogcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUubGV2ZWwgKyAxIDogMCxcbiAgICAgICAgICAgIGluZGV4OiBwYXJ0aWFsTm9kZS5pbmRleCxcbiAgICAgICAgICAgIHJlbmRlcmVkOiBwYXJ0aWFsTm9kZS5yZW5kZXJlZCxcbiAgICAgICAgICAgIHRleHRWYWx1ZTogcGFydGlhbE5vZGUudGV4dFZhbHVlLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBhcnRpYWxOb2RlW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgICAgIHdyYXBwZXI6IHBhcnRpYWxOb2RlLndyYXBwZXIsXG4gICAgICAgICAgICBzaG91bGRJbnZhbGlkYXRlOiBwYXJ0aWFsTm9kZS5zaG91bGRJbnZhbGlkYXRlLFxuICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcyxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6ICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZShmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsTm9kZS5oYXNDaGlsZE5vZGVzKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBwYXJ0aWFsTm9kZS5jaGlsZE5vZGVzKCkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY2hpbGQga2V5cyBhcmUgZ2xvYmFsbHkgdW5pcXVlIGJ5IHByZXBlbmRpbmcgdGhlIHBhcmVudCBub2RlJ3Mga2V5XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbGluZSBlbnRpcmVseSBhbmQgZW5mb3JjZSB0aGF0IHVzZXJzIGFsd2F5cyBwcm92aWRlIHVuaXF1ZSBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgdGhpcyBsaW5lIHdpbGwgaGF2ZSBpc3N1ZXMgd2hlbiBhIHBhcmVudCBoYXMgYSBrZXkgYGFgIGFuZCBhIGNoaWxkIHdpdGgga2V5IGBiY2BcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGFub3RoZXIgcGFyZW50IGhhcyBrZXkgYGFiYCBhbmQgaXRzIGNoaWxkIGhhcyBhIGtleSBgY2AuIFRoZSBjb21iaW5lZCBrZXlzIHdvdWxkIHJlc3VsdCBpbiBib3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkcmVuIGhhdmluZyBhIGtleSBvZiBgYWJjYC5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQua2V5ID0gYCR7bm9kZS5rZXl9JHtjaGlsZC5rZXl9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5nZXRGdWxsTm9kZShjaGlsZCwgYnVpbGRlci5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZCksIG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbn1cbi8vIFdyYXBzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIGFuIGl0ZXJhYmxlIG9iamVjdCwgYW5kIGNhY2hlcyB0aGUgcmVzdWx0cy5cbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZShpdGVyYXRvcikge1xuICAgIGxldCBjYWNoZSA9IFtdO1xuICAgIGxldCBpdGVyYWJsZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY2FjaGUpeWllbGQgaXRlbTtcbiAgICAgICAgICAgIGlmICghaXRlcmFibGUpIGl0ZXJhYmxlID0gaXRlcmF0b3IoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmFibGUpe1xuICAgICAgICAgICAgICAgIGNhY2hlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZShvdXRlciwgaW5uZXIpIHtcbiAgICBpZiAob3V0ZXIgJiYgaW5uZXIpIHJldHVybiAoZWxlbWVudCk9Pm91dGVyKGlubmVyKGVsZW1lbnQpKTtcbiAgICBpZiAob3V0ZXIpIHJldHVybiBvdXRlcjtcbiAgICBpZiAoaW5uZXIpIHJldHVybiBpbm5lcjtcbn1cbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5cbmZ1bmN0aW9uICQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5KHByb3BzLCBmYWN0b3J5LCBjb250ZXh0KSB7XG4gICAgbGV0IGJ1aWxkZXIgPSAoMCwgJHR5VzZBJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxKSgpLCBbXSk7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24gfSA9IHByb3BzO1xuICAgIGxldCByZXN1bHQgPSAoMCwgJHR5VzZBJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5idWlsZCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICBpdGVtczogaXRlbXNcbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KG5vZGVzKTtcbiAgICB9LCBbXG4gICAgICAgIGJ1aWxkZXIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZmFjdG9yeVxuICAgIF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyhub2RlLCBjb2xsZWN0aW9uKSB7XG4gICAgLy8gTmV3IEFQSTogY2FsbCBjb2xsZWN0aW9uLmdldENoaWxkcmVuIHdpdGggdGhlIG5vZGUga2V5LlxuICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29sbGVjdGlvbi5nZXRDaGlsZHJlbihub2RlLmtleSk7XG4gICAgLy8gT2xkIEFQSTogYWNjZXNzIGNoaWxkTm9kZXMgZGlyZWN0bHkuXG4gICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlcztcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCRmYmRlYWE2YTc2Njk0ZjcxKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyKGl0ZXJhYmxlLCAwKTtcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyKGl0ZXJhYmxlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmFibGUpe1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHJldHVybiBpdGVtO1xuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YoaXRlcmFibGUpIHtcbiAgICBsZXQgbGFzdEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpbGFzdEl0ZW0gPSB2YWx1ZTtcbiAgICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2KGNvbGxlY3Rpb24sIGEsIGIpIHtcbiAgICAvLyBJZiB0aGUgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50LCBjb21wYXJlIHRoZWlyIGluZGljZXMuXG4gICAgaWYgKGEucGFyZW50S2V5ID09PSBiLnBhcmVudEtleSkgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgIC8vIE90aGVyd2lzZSwgY29sbGVjdCBhbGwgb2YgdGhlIGFuY2VzdG9ycyBmcm9tIGVhY2ggbm9kZSwgYW5kIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGRvZXNuJ3QgbWF0Y2ggc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAvLyBJbmNsdWRlIHRoZSBiYXNlIG5vZGVzIGluIGNhc2Ugd2UgYXJlIGNvbXBhcmluZyBub2RlcyBvZiBkaWZmZXJlbnQgbGV2ZWxzIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgdGhlIGhpZ2hlciBub2RlIHRvIHRoZSBsb3dlciBsZXZlbCBub2RlJ3NcbiAgICAvLyBhbmNlc3RvciBvZiB0aGUgc2FtZSBsZXZlbFxuICAgIGxldCBhQW5jZXN0b3JzID0gW1xuICAgICAgICAuLi4kYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIGEpLFxuICAgICAgICBhXG4gICAgXTtcbiAgICBsZXQgYkFuY2VzdG9ycyA9IFtcbiAgICAgICAgLi4uJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBiKSxcbiAgICAgICAgYlxuICAgIF07XG4gICAgbGV0IGZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3RvciA9IGFBbmNlc3RvcnMuc2xpY2UoMCwgYkFuY2VzdG9ycy5sZW5ndGgpLmZpbmRJbmRleCgoYSwgaSk9PmEgIT09IGJBbmNlc3RvcnNbaV0pO1xuICAgIGlmIChmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IgIT09IC0xKSB7XG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGluZGljZXMgb2YgdHdvIGNoaWxkcmVuIHdpdGhpbiB0aGUgY29tbW9uIGFuY2VzdG9yLlxuICAgICAgICBhID0gYUFuY2VzdG9yc1tmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3JdO1xuICAgICAgICBiID0gYkFuY2VzdG9yc1tmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3JdO1xuICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzbid0IGEgbm9uIG1hdGNoaW5nIGFuY2VzdG9yLCB3ZSBtaWdodCBiZSBpbiBhIGNhc2Ugd2hlcmUgb25lIG9mIHRoZSBub2RlcyBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIG90aGVyLlxuICAgIGlmIChhQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGIpID49IDApIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGJBbmNlc3RvcnMuZmluZEluZGV4KChub2RlKT0+bm9kZSA9PT0gYSkgPj0gMCkgcmV0dXJuIC0xO1xuICAgIC8vIPCfpLdcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIG5vZGUpIHtcbiAgICBsZXQgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUucGFyZW50S2V5KSAhPSBudWxsKXtcbiAgICAgICAgbm9kZSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShub2RlLnBhcmVudEtleSk7XG4gICAgICAgIHBhcmVudHMudW5zaGlmdChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cblxuY29uc3QgJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uICQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgY291bnQgPSAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUuZ2V0KGNvbGxlY3Rpb24pO1xuICAgIGlmIChjb3VudCAhPSBudWxsKSByZXR1cm4gY291bnQ7XG4gICAgY291bnQgPSAwO1xuICAgIGxldCBjb3VudEl0ZW1zID0gKGl0ZW1zKT0+e1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKWlmIChpdGVtLnR5cGUgPT09IFwic2VjdGlvblwiKSBjb3VudEl0ZW1zKCgwLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMykoaXRlbSwgY29sbGVjdGlvbikpO1xuICAgICAgICBlbHNlIGNvdW50Kys7XG4gICAgfTtcbiAgICBjb3VudEl0ZW1zKGNvbGxlY3Rpb24pO1xuICAgICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZS5zZXQoY29sbGVjdGlvbiwgY291bnQpO1xuICAgIHJldHVybiBjb3VudDtcbn1cblxuXG5cblxuXG5cbmV4cG9ydCB7JGMxZDdmYjJlYzkxYmFlNzEkZXhwb3J0JDZkMDg3NzNkMmU2NmY4ZjIgYXMgSXRlbSwgJDlmYzQ4NTI3NzFkMDc5ZWIkZXhwb3J0JDZlMmM4ZjA4MTFhNDc0Y2UgYXMgU2VjdGlvbiwgJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkgYXMgdXNlQ29sbGVjdGlvbiwgJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIgYXMgZ2V0SXRlbUNvdW50LCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyBhcyBnZXRDaGlsZE5vZGVzLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MSBhcyBnZXRGaXJzdEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmIGFzIGdldExhc3RJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMiBhcyBnZXROdGhJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2IGFzIGNvbXBhcmVOb2RlT3JkZXIsICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIGFzIENvbGxlY3Rpb25CdWlsZGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/combobox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComboBoxState: () => (/* binding */ $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\nfunction $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {\n    var _collection_getItem, _collection_getItem1;\n    let { defaultFilter: defaultFilter, menuTrigger: menuTrigger = \"input\", allowsEmptyCollection: allowsEmptyCollection = false, allowsCustomValue: allowsCustomValue, shouldCloseOnBlur: shouldCloseOnBlur = true } = props;\n    let [showAllItems, setShowAllItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocused, setFocusedState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let onSelectionChange = (key)=>{\n        if (props.onSelectionChange) props.onSelectionChange(key);\n        // If key is the same, reset the inputValue and close the menu\n        // (scenario: user clicks on already selected option)\n        if (key === selectedKey) {\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    var _props_items;\n    let { collection: collection, selectionManager: selectionManager, selectedKey: selectedKey, setSelectedKey: setSelectedKey, selectedItem: selectedItem, disabledKeys: disabledKeys } = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        onSelectionChange: onSelectionChange,\n        items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems\n    });\n    var _props_defaultInputValue, _ref;\n    let [inputValue, setInputValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : \"\", props.onInputChange);\n    // Preserve original collection so we can show all items on demand\n    let originalCollection = collection;\n    let filteredCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>// No default filter if items are controlled.\n        props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [\n        collection,\n        inputValue,\n        defaultFilter,\n        props.items\n    ]);\n    let [lastCollection, setLastCollection] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(filteredCollection);\n    // Track what action is attempting to open the menu\n    let menuOpenTrigger = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"focus\");\n    let onOpenChange = (open)=>{\n        if (props.onOpenChange) props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n        selectionManager.setFocused(open);\n        if (!open) selectionManager.setFocusedKey(null);\n    };\n    let triggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__.useOverlayTriggerState)({\n        ...props,\n        onOpenChange: onOpenChange,\n        isOpen: undefined,\n        defaultOpen: undefined\n    });\n    let open = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // Prevent open operations from triggering if there is nothing to display\n        // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n        // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n        if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {\n            if (displayAllItems && !triggerState.isOpen && props.items === undefined) // Show all items if menu is manually opened. Only care about this if items are undefined\n            setShowAllItems(true);\n            menuOpenTrigger.current = trigger;\n            setFocusStrategy(focusStrategy);\n            triggerState.open();\n        }\n    };\n    let toggle = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n        if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;\n        if (displayAllItems && !triggerState.isOpen && props.items === undefined) // Show all items if menu is toggled open. Only care about this if items are undefined\n        setShowAllItems(true);\n        // Only update the menuOpenTrigger if menu is currently closed\n        if (!triggerState.isOpen) menuOpenTrigger.current = trigger;\n        toggleMenu(focusStrategy);\n    };\n    let updateLastCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setLastCollection(showAllItems ? originalCollection : filteredCollection);\n    }, [\n        showAllItems,\n        originalCollection,\n        filteredCollection\n    ]);\n    // If menu is going to close, save the current collection so we can freeze the displayed collection when the\n    // user clicks outside the popover to close the menu. Prevents the menu contents from updating as the menu closes.\n    let toggleMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        if (triggerState.isOpen) updateLastCollection();\n        setFocusStrategy(focusStrategy);\n        triggerState.toggle();\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let closeMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (triggerState.isOpen) {\n            updateLastCollection();\n            triggerState.close();\n        }\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(inputValue);\n    let resetInputValue = ()=>{\n        var _collection_getItem;\n        var _collection_getItem_textValue;\n        let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        setLastValue(itemText);\n        setInputValue(itemText);\n    };\n    var _props_selectedKey, _ref1;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);\n    var _collection_getItem_textValue;\n    let lastSelectedKeyText = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\");\n    // intentional omit dependency array, want this to happen on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _collection_getItem;\n        // Open and close menu automatically when the input value changes if the input is focused,\n        // and there are items in the collection or allowEmptyCollection is true.\n        if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== \"manual\") open(null, \"input\");\n        // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n        // but we are currently showing all items via button press\n        if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();\n        // Close when an item is selected.\n        if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();\n        // Clear focused key when input value changes and display filtered collection again.\n        if (inputValue !== lastValue) {\n            selectionManager.setFocusedKey(null);\n            setShowAllItems(false);\n            // Set selectedKey to null when the user clears the input.\n            // If controlled, this is the application developer's responsibility.\n            if (inputValue === \"\" && (props.inputValue === undefined || props.selectedKey === undefined)) setSelectedKey(null);\n        }\n        // If the selectedKey changed, update the input value.\n        // Do nothing if both inputValue and selectedKey are controlled.\n        // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n        if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) resetInputValue();\n        else if (lastValue !== inputValue) setLastValue(inputValue);\n        var _collection_getItem_textValue;\n        // Update the inputValue if the selected item's text changes from its last tracked value.\n        // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n        // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n        // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n        let selectedItemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n            if (lastSelectedKeyText.current !== selectedItemText) {\n                setLastValue(selectedItemText);\n                setInputValue(selectedItemText);\n            }\n        }\n        lastSelectedKey.current = selectedKey;\n        lastSelectedKeyText.current = selectedItemText;\n    });\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_4__.useFormValidationState)({\n        ...props,\n        value: (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                inputValue: inputValue,\n                selectedKey: selectedKey\n            }), [\n            inputValue,\n            selectedKey\n        ])\n    });\n    // Revert input value and close menu\n    let revert = ()=>{\n        if (allowsCustomValue && selectedKey == null) commitCustomValue();\n        else commitSelection();\n    };\n    let commitCustomValue = ()=>{\n        lastSelectedKey.current = null;\n        setSelectedKey(null);\n        closeMenu();\n    };\n    let commitSelection = ()=>{\n        // If multiple things are controlled, call onSelectionChange\n        if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n            var _collection_getItem;\n            props.onSelectionChange(selectedKey);\n            var _collection_getItem_textValue;\n            // Stop menu from reopening from useEffect\n            let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            setLastValue(itemText);\n            closeMenu();\n        } else {\n            // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    const commitValue = ()=>{\n        if (allowsCustomValue) {\n            var _collection_getItem;\n            var _collection_getItem_textValue;\n            const itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            inputValue === itemText ? commitSelection() : commitCustomValue();\n        } else // Reset inputValue and close menu\n        commitSelection();\n    };\n    let commit = ()=>{\n        if (triggerState.isOpen && selectionManager.focusedKey != null) {\n            // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n            // fire onSelectionChange to allow the application to control the closing.\n            if (selectedKey === selectionManager.focusedKey) commitSelection();\n            else setSelectedKey(selectionManager.focusedKey);\n        } else commitValue();\n    };\n    let valueOnFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(inputValue);\n    let setFocused = (isFocused)=>{\n        if (isFocused) {\n            valueOnFocus.current = inputValue;\n            if (menuTrigger === \"focus\") open(null, \"focus\");\n        } else {\n            if (shouldCloseOnBlur) commitValue();\n            if (inputValue !== valueOnFocus.current) validation.commitValidation();\n        }\n        setFocusedState(isFocused);\n    };\n    let displayedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (triggerState.isOpen) {\n            if (showAllItems) return originalCollection;\n            else return filteredCollection;\n        } else return lastCollection;\n    }, [\n        triggerState.isOpen,\n        originalCollection,\n        filteredCollection,\n        showAllItems,\n        lastCollection\n    ]);\n    return {\n        ...validation,\n        ...triggerState,\n        focusStrategy: focusStrategy,\n        toggle: toggle,\n        open: open,\n        close: commitValue,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        disabledKeys: disabledKeys,\n        isFocused: isFocused,\n        setFocused: setFocused,\n        selectedItem: selectedItem,\n        collection: displayedCollection,\n        inputValue: inputValue,\n        setInputValue: setInputValue,\n        commit: commit,\n        revert: revert\n    };\n}\nfunction $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {\n    return new (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.ListCollection)($a9e7382a7d111cb5$var$filterNodes(collection, collection, inputValue, filter));\n}\nfunction $a9e7382a7d111cb5$var$filterNodes(collection, nodes, inputValue, filter) {\n    let filteredNode = [];\n    for (let node of nodes){\n        if (node.type === \"section\" && node.hasChildNodes) {\n            let filtered = $a9e7382a7d111cb5$var$filterNodes(collection, (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__.getChildNodes)(node, collection), inputValue, filter);\n            if ([\n                ...filtered\n            ].some((node)=>node.type === \"item\")) filteredNode.push({\n                ...node,\n                childNodes: filtered\n            });\n        } else if (node.type === \"item\" && filter(node.textValue, inputValue)) filteredNode.push({\n            ...node\n        });\n        else if (node.type !== \"item\") filteredNode.push({\n            ...node\n        });\n    }\n    return filteredNode;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEY7QUFDWDtBQUN3RDtBQUMrQjtBQUNuRjtBQUNXOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQSxVQUFVLDRNQUE0TTtBQUN0Tiw4Q0FBOEMsMkNBQWU7QUFDN0QsMkNBQTJDLDJDQUFlO0FBQzFELGdEQUFnRCwyQ0FBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0tBQStLLE1BQU0seUVBQStCO0FBQzlOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyxvRUFBeUI7QUFDbkU7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQWU7QUFDakU7QUFDQSw4QkFBOEIseUNBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyRUFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBa0I7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBYTtBQUMzQztBQUNBLGtDQUFrQyx5Q0FBYTtBQUMvQztBQUNBO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5Qix1RUFBNkI7QUFDdEQ7QUFDQSxtQkFBbUIsMENBQWM7QUFDakM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyQkFBMkIseUNBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQ0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHFFQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7QUFLdUU7QUFDdkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzP2E5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRrNlBwdSR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRrNlBwdSRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIGFzICRrNlBwdSR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUsIExpc3RDb2xsZWN0aW9uIGFzICRrNlBwdSRMaXN0Q29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2xpc3RcIjtcbmltcG9ydCB7dXNlU3RhdGUgYXMgJGs2UHB1JHVzZVN0YXRlLCB1c2VNZW1vIGFzICRrNlBwdSR1c2VNZW1vLCB1c2VSZWYgYXMgJGs2UHB1JHVzZVJlZiwgdXNlQ2FsbGJhY2sgYXMgJGs2UHB1JHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJGs2UHB1JHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkazZQcHUkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqIFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JGV4cG9ydCRiNDUzYTNiZmQ0YTVmYTllKHByb3BzKSB7XG4gICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW0sIF9jb2xsZWN0aW9uX2dldEl0ZW0xO1xuICAgIGxldCB7IGRlZmF1bHRGaWx0ZXI6IGRlZmF1bHRGaWx0ZXIsIG1lbnVUcmlnZ2VyOiBtZW51VHJpZ2dlciA9IFwiaW5wdXRcIiwgYWxsb3dzRW1wdHlDb2xsZWN0aW9uOiBhbGxvd3NFbXB0eUNvbGxlY3Rpb24gPSBmYWxzZSwgYWxsb3dzQ3VzdG9tVmFsdWU6IGFsbG93c0N1c3RvbVZhbHVlLCBzaG91bGRDbG9zZU9uQmx1cjogc2hvdWxkQ2xvc2VPbkJsdXIgPSB0cnVlIH0gPSBwcm9wcztcbiAgICBsZXQgW3Nob3dBbGxJdGVtcywgc2V0U2hvd0FsbEl0ZW1zXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzRm9jdXNlZCwgc2V0Rm9jdXNlZFN0YXRlXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2ZvY3VzU3RyYXRlZ3ksIHNldEZvY3VzU3RyYXRlZ3ldID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKGtleSk9PntcbiAgICAgICAgaWYgKHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xuICAgICAgICAvLyBJZiBrZXkgaXMgdGhlIHNhbWUsIHJlc2V0IHRoZSBpbnB1dFZhbHVlIGFuZCBjbG9zZSB0aGUgbWVudVxuICAgICAgICAvLyAoc2NlbmFyaW86IHVzZXIgY2xpY2tzIG9uIGFscmVhZHkgc2VsZWN0ZWQgb3B0aW9uKVxuICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZEtleSkge1xuICAgICAgICAgICAgcmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9wcm9wc19pdGVtcztcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLCBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXksIHNldFNlbGVjdGVkS2V5OiBzZXRTZWxlY3RlZEtleSwgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW0sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzIH0gPSAoMCwgJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgICBpdGVtczogKF9wcm9wc19pdGVtcyA9IHByb3BzLml0ZW1zKSAhPT0gbnVsbCAmJiBfcHJvcHNfaXRlbXMgIT09IHZvaWQgMCA/IF9wcm9wc19pdGVtcyA6IHByb3BzLmRlZmF1bHRJdGVtc1xuICAgIH0pO1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUsIF9yZWY7XG4gICAgbGV0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9ICgwLCAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pbnB1dFZhbHVlLCAoX3JlZiA9IChfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgPSBwcm9wcy5kZWZhdWx0SW5wdXRWYWx1ZSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgOiAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogXCJcIiwgcHJvcHMub25JbnB1dENoYW5nZSk7XG4gICAgLy8gUHJlc2VydmUgb3JpZ2luYWwgY29sbGVjdGlvbiBzbyB3ZSBjYW4gc2hvdyBhbGwgaXRlbXMgb24gZGVtYW5kXG4gICAgbGV0IG9yaWdpbmFsQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgbGV0IGZpbHRlcmVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9Pi8vIE5vIGRlZmF1bHQgZmlsdGVyIGlmIGl0ZW1zIGFyZSBjb250cm9sbGVkLlxuICAgICAgICBwcm9wcy5pdGVtcyAhPSBudWxsIHx8ICFkZWZhdWx0RmlsdGVyID8gY29sbGVjdGlvbiA6ICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGlucHV0VmFsdWUsIGRlZmF1bHRGaWx0ZXIpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgIGRlZmF1bHRGaWx0ZXIsXG4gICAgICAgIHByb3BzLml0ZW1zXG4gICAgXSk7XG4gICAgbGV0IFtsYXN0Q29sbGVjdGlvbiwgc2V0TGFzdENvbGxlY3Rpb25dID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoZmlsdGVyZWRDb2xsZWN0aW9uKTtcbiAgICAvLyBUcmFjayB3aGF0IGFjdGlvbiBpcyBhdHRlbXB0aW5nIHRvIG9wZW4gdGhlIG1lbnVcbiAgICBsZXQgbWVudU9wZW5UcmlnZ2VyID0gKDAsICRrNlBwdSR1c2VSZWYpKFwiZm9jdXNcIik7XG4gICAgbGV0IG9uT3BlbkNoYW5nZSA9IChvcGVuKT0+e1xuICAgICAgICBpZiAocHJvcHMub25PcGVuQ2hhbmdlKSBwcm9wcy5vbk9wZW5DaGFuZ2Uob3Blbiwgb3BlbiA/IG1lbnVPcGVuVHJpZ2dlci5jdXJyZW50IDogdW5kZWZpbmVkKTtcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkKG9wZW4pO1xuICAgICAgICBpZiAoIW9wZW4pIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICB9O1xuICAgIGxldCB0cmlnZ2VyU3RhdGUgPSAoMCwgJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9uT3BlbkNoYW5nZTogb25PcGVuQ2hhbmdlLFxuICAgICAgICBpc09wZW46IHVuZGVmaW5lZCxcbiAgICAgICAgZGVmYXVsdE9wZW46IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGxldCBvcGVuID0gKGZvY3VzU3RyYXRlZ3kgPSBudWxsLCB0cmlnZ2VyKT0+e1xuICAgICAgICBsZXQgZGlzcGxheUFsbEl0ZW1zID0gdHJpZ2dlciA9PT0gXCJtYW51YWxcIiB8fCB0cmlnZ2VyID09PSBcImZvY3VzXCIgJiYgbWVudVRyaWdnZXIgPT09IFwiZm9jdXNcIjtcbiAgICAgICAgLy8gUHJldmVudCBvcGVuIG9wZXJhdGlvbnMgZnJvbSB0cmlnZ2VyaW5nIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZGlzcGxheVxuICAgICAgICAvLyBBbHNvIHByZXZlbnQgb3BlbiBvcGVyYXRpb25zIGZyb20gdHJpZ2dlcmluZyBpZiBpdGVtcyBhcmUgdW5jb250cm9sbGVkIGJ1dCBkZWZhdWx0SXRlbXMgaXMgZW1wdHksIGV2ZW4gaWYgZGlzcGxheUFsbEl0ZW1zIGlzIHRydWUuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBjb21ib2JveGVzIHdpdGggZW1wdHkgZGVmYXVsdEl0ZW1zIGZyb20gb3BlbmluZyBidXQgYWxsb3cgY29udHJvbGxlZCBpdGVtcyBjb21ib2JveGVzIHRvIG9wZW4gZXZlbiBpZiB0aGUgaW5pdGFsIGxpc3QgaXMgZW1wdHkgKGFzc3VtcHRpb24gaXMgdXNlciB3aWxsIHByb3ZpZGUgc3dhcCB0aGUgZW1wdHkgbGlzdCB3aXRoIGEgYmFzZSBsaXN0IHZpYSBvbk9wZW5DaGFuZ2UgcmV0dXJuaW5nIGBtZW51VHJpZ2dlcmAgbWFudWFsKVxuICAgICAgICBpZiAoYWxsb3dzRW1wdHlDb2xsZWN0aW9uIHx8IGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBkaXNwbGF5QWxsSXRlbXMgJiYgb3JpZ2luYWxDb2xsZWN0aW9uLnNpemUgPiAwIHx8IHByb3BzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGxheUFsbEl0ZW1zICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIHByb3BzLml0ZW1zID09PSB1bmRlZmluZWQpIC8vIFNob3cgYWxsIGl0ZW1zIGlmIG1lbnUgaXMgbWFudWFsbHkgb3BlbmVkLiBPbmx5IGNhcmUgYWJvdXQgdGhpcyBpZiBpdGVtcyBhcmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBzZXRTaG93QWxsSXRlbXModHJ1ZSk7XG4gICAgICAgICAgICBtZW51T3BlblRyaWdnZXIuY3VycmVudCA9IHRyaWdnZXI7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgdHJpZ2dlclN0YXRlLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHRvZ2dsZSA9IChmb2N1c1N0cmF0ZWd5ID0gbnVsbCwgdHJpZ2dlcik9PntcbiAgICAgICAgbGV0IGRpc3BsYXlBbGxJdGVtcyA9IHRyaWdnZXIgPT09IFwibWFudWFsXCIgfHwgdHJpZ2dlciA9PT0gXCJmb2N1c1wiICYmIG1lbnVUcmlnZ2VyID09PSBcImZvY3VzXCI7XG4gICAgICAgIC8vIElmIHRoZSBtZW51IGlzIGNsb3NlZCBhbmQgdGhlcmUgaXMgbm90aGluZyB0byBkaXNwbGF5LCBlYXJseSByZXR1cm4gc28gdG9nZ2xlIGlzbid0IGNhbGxlZCB0byBwcmV2ZW50IGV4dHJhbmVvdXMgb25PcGVuQ2hhbmdlXG4gICAgICAgIGlmICghKGFsbG93c0VtcHR5Q29sbGVjdGlvbiB8fCBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgZGlzcGxheUFsbEl0ZW1zICYmIG9yaWdpbmFsQ29sbGVjdGlvbi5zaXplID4gMCB8fCBwcm9wcy5pdGVtcykgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4pIHJldHVybjtcbiAgICAgICAgaWYgKGRpc3BsYXlBbGxJdGVtcyAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBwcm9wcy5pdGVtcyA9PT0gdW5kZWZpbmVkKSAvLyBTaG93IGFsbCBpdGVtcyBpZiBtZW51IGlzIHRvZ2dsZWQgb3Blbi4gT25seSBjYXJlIGFib3V0IHRoaXMgaWYgaXRlbXMgYXJlIHVuZGVmaW5lZFxuICAgICAgICBzZXRTaG93QWxsSXRlbXModHJ1ZSk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBtZW51T3BlblRyaWdnZXIgaWYgbWVudSBpcyBjdXJyZW50bHkgY2xvc2VkXG4gICAgICAgIGlmICghdHJpZ2dlclN0YXRlLmlzT3BlbikgbWVudU9wZW5UcmlnZ2VyLmN1cnJlbnQgPSB0cmlnZ2VyO1xuICAgICAgICB0b2dnbGVNZW51KGZvY3VzU3RyYXRlZ3kpO1xuICAgIH07XG4gICAgbGV0IHVwZGF0ZUxhc3RDb2xsZWN0aW9uID0gKDAsICRrNlBwdSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0TGFzdENvbGxlY3Rpb24oc2hvd0FsbEl0ZW1zID8gb3JpZ2luYWxDb2xsZWN0aW9uIDogZmlsdGVyZWRDb2xsZWN0aW9uKTtcbiAgICB9LCBbXG4gICAgICAgIHNob3dBbGxJdGVtcyxcbiAgICAgICAgb3JpZ2luYWxDb2xsZWN0aW9uLFxuICAgICAgICBmaWx0ZXJlZENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICAvLyBJZiBtZW51IGlzIGdvaW5nIHRvIGNsb3NlLCBzYXZlIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gc28gd2UgY2FuIGZyZWV6ZSB0aGUgZGlzcGxheWVkIGNvbGxlY3Rpb24gd2hlbiB0aGVcbiAgICAvLyB1c2VyIGNsaWNrcyBvdXRzaWRlIHRoZSBwb3BvdmVyIHRvIGNsb3NlIHRoZSBtZW51LiBQcmV2ZW50cyB0aGUgbWVudSBjb250ZW50cyBmcm9tIHVwZGF0aW5nIGFzIHRoZSBtZW51IGNsb3Nlcy5cbiAgICBsZXQgdG9nZ2xlTWVudSA9ICgwLCAkazZQcHUkdXNlQ2FsbGJhY2spKChmb2N1c1N0cmF0ZWd5ID0gbnVsbCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgIHRyaWdnZXJTdGF0ZS50b2dnbGUoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyaWdnZXJTdGF0ZSxcbiAgICAgICAgdXBkYXRlTGFzdENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICBsZXQgY2xvc2VNZW51ID0gKDAsICRrNlBwdSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB0cmlnZ2VyU3RhdGUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdHJpZ2dlclN0YXRlLFxuICAgICAgICB1cGRhdGVMYXN0Q29sbGVjdGlvblxuICAgIF0pO1xuICAgIGxldCBbbGFzdFZhbHVlLCBzZXRMYXN0VmFsdWVdID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoaW5wdXRWYWx1ZSk7XG4gICAgbGV0IHJlc2V0SW5wdXRWYWx1ZSA9ICgpPT57XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgIGxldCBpdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgIHNldExhc3RWYWx1ZShpdGVtVGV4dCk7XG4gICAgICAgIHNldElucHV0VmFsdWUoaXRlbVRleHQpO1xuICAgIH07XG4gICAgdmFyIF9wcm9wc19zZWxlY3RlZEtleSwgX3JlZjE7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleSA9ICgwLCAkazZQcHUkdXNlUmVmKSgoX3JlZjEgPSAoX3Byb3BzX3NlbGVjdGVkS2V5ID0gcHJvcHMuc2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19zZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX3NlbGVjdGVkS2V5IDogcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5KSAhPT0gbnVsbCAmJiBfcmVmMSAhPT0gdm9pZCAwID8gX3JlZjEgOiBudWxsKTtcbiAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleVRleHQgPSAoMCwgJGs2UHB1JHVzZVJlZikoKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0xID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0xLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIik7XG4gICAgLy8gaW50ZW50aW9uYWwgb21pdCBkZXBlbmRlbmN5IGFycmF5LCB3YW50IHRoaXMgdG8gaGFwcGVuIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAoMCwgJGs2UHB1JHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgIC8vIE9wZW4gYW5kIGNsb3NlIG1lbnUgYXV0b21hdGljYWxseSB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VzIGlmIHRoZSBpbnB1dCBpcyBmb2N1c2VkLFxuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG9yIGFsbG93RW1wdHlDb2xsZWN0aW9uIGlzIHRydWUuXG4gICAgICAgIGlmIChpc0ZvY3VzZWQgJiYgKGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBhbGxvd3NFbXB0eUNvbGxlY3Rpb24pICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIGlucHV0VmFsdWUgIT09IGxhc3RWYWx1ZSAmJiBtZW51VHJpZ2dlciAhPT0gXCJtYW51YWxcIikgb3BlbihudWxsLCBcImlucHV0XCIpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgbWVudSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gRG9uJ3QgY2xvc2UgbWVudSBpZiBmaWx0ZXJlZCBjb2xsZWN0aW9uIHNpemUgaXMgMFxuICAgICAgICAvLyBidXQgd2UgYXJlIGN1cnJlbnRseSBzaG93aW5nIGFsbCBpdGVtcyB2aWEgYnV0dG9uIHByZXNzXG4gICAgICAgIGlmICghc2hvd0FsbEl0ZW1zICYmICFhbGxvd3NFbXB0eUNvbGxlY3Rpb24gJiYgdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA9PT0gMCkgY2xvc2VNZW51KCk7XG4gICAgICAgIC8vIENsb3NlIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBjbG9zZU1lbnUoKTtcbiAgICAgICAgLy8gQ2xlYXIgZm9jdXNlZCBrZXkgd2hlbiBpbnB1dCB2YWx1ZSBjaGFuZ2VzIGFuZCBkaXNwbGF5IGZpbHRlcmVkIGNvbGxlY3Rpb24gYWdhaW4uXG4gICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICAgICAgICAgIHNldFNob3dBbGxJdGVtcyhmYWxzZSk7XG4gICAgICAgICAgICAvLyBTZXQgc2VsZWN0ZWRLZXkgdG8gbnVsbCB3aGVuIHRoZSB1c2VyIGNsZWFycyB0aGUgaW5wdXQuXG4gICAgICAgICAgICAvLyBJZiBjb250cm9sbGVkLCB0aGlzIGlzIHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIncyByZXNwb25zaWJpbGl0eS5cbiAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlID09PSBcIlwiICYmIChwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMuc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkpIHNldFNlbGVjdGVkS2V5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZEtleSBjaGFuZ2VkLCB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGJvdGggaW5wdXRWYWx1ZSBhbmQgc2VsZWN0ZWRLZXkgYXJlIGNvbnRyb2xsZWQuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgaXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIHVwZGF0ZSBpbnB1dFZhbHVlIGluIG9uU2VsZWN0aW9uQ2hhbmdlLlxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ICYmIChwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMuc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkpIHJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICBlbHNlIGlmIChsYXN0VmFsdWUgIT09IGlucHV0VmFsdWUpIHNldExhc3RWYWx1ZShpbnB1dFZhbHVlKTtcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0VmFsdWUgaWYgdGhlIHNlbGVjdGVkIGl0ZW0ncyB0ZXh0IGNoYW5nZXMgZnJvbSBpdHMgbGFzdCB0cmFja2VkIHZhbHVlLlxuICAgICAgICAvLyBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBhIHNlbGVjdGVkS2V5IGlzIHNwZWNpZmllZCBidXQgdGhlIGl0ZW1zIGFyZW4ndCBhdmFpbGFibGUgKGFzeW5jIGxvYWRpbmcpIG9yIHRoZSBzZWxlY3RlZCBpdGVtJ3MgdGV4dCB2YWx1ZSB1cGRhdGVzLlxuICAgICAgICAvLyBPbmx5IHJlc2V0IGlmIHRoZSB1c2VyIGlzbid0IGN1cnJlbnRseSB3aXRoaW4gdGhlIGZpZWxkIHNvIHdlIGRvbid0IGVycm9uZW91c2x5IG1vZGlmeSB1c2VyIGlucHV0LlxuICAgICAgICAvLyBJZiBpbnB1dFZhbHVlIGlzIGNvbnRyb2xsZWQsIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gdXBkYXRlIHRoZSBpbnB1dFZhbHVlIHdoZW4gaXRlbXMgY2hhbmdlLlxuICAgICAgICBsZXQgc2VsZWN0ZWRJdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgIGlmICghaXNGb2N1c2VkICYmIHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgcHJvcHMuaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkS2V5ID09PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCAhPT0gc2VsZWN0ZWRJdGVtVGV4dCkge1xuICAgICAgICAgICAgICAgIHNldExhc3RWYWx1ZShzZWxlY3RlZEl0ZW1UZXh0KTtcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFZhbHVlKHNlbGVjdGVkSXRlbVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ID0gc2VsZWN0ZWRLZXk7XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCA9IHNlbGVjdGVkSXRlbVRleHQ7XG4gICAgfSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGs2UHB1JHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHZhbHVlOiAoMCwgJGs2UHB1JHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5XG4gICAgICAgICAgICB9KSwgW1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgIF0pXG4gICAgfSk7XG4gICAgLy8gUmV2ZXJ0IGlucHV0IHZhbHVlIGFuZCBjbG9zZSBtZW51XG4gICAgbGV0IHJldmVydCA9ICgpPT57XG4gICAgICAgIGlmIChhbGxvd3NDdXN0b21WYWx1ZSAmJiBzZWxlY3RlZEtleSA9PSBudWxsKSBjb21taXRDdXN0b21WYWx1ZSgpO1xuICAgICAgICBlbHNlIGNvbW1pdFNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgbGV0IGNvbW1pdEN1c3RvbVZhbHVlID0gKCk9PntcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBzZXRTZWxlY3RlZEtleShudWxsKTtcbiAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgfTtcbiAgICBsZXQgY29tbWl0U2VsZWN0aW9uID0gKCk9PntcbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgdGhpbmdzIGFyZSBjb250cm9sbGVkLCBjYWxsIG9uU2VsZWN0aW9uQ2hhbmdlXG4gICAgICAgIGlmIChwcm9wcy5zZWxlY3RlZEtleSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgICAgICBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShzZWxlY3RlZEtleSk7XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgICAgICAvLyBTdG9wIG1lbnUgZnJvbSByZW9wZW5pbmcgZnJvbSB1c2VFZmZlY3RcbiAgICAgICAgICAgIGxldCBpdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICBzZXRMYXN0VmFsdWUoaXRlbVRleHQpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IGEgc2luZ2xlIGFzcGVjdCBvZiBjb21ib2JveCBpcyBjb250cm9sbGVkLCByZXNldCBpbnB1dCB2YWx1ZSBhbmQgY2xvc2UgbWVudSBmb3IgdGhlIHVzZXJcbiAgICAgICAgICAgIHJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbW1pdFZhbHVlID0gKCk9PntcbiAgICAgICAgaWYgKGFsbG93c0N1c3RvbVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPT09IGl0ZW1UZXh0ID8gY29tbWl0U2VsZWN0aW9uKCkgOiBjb21taXRDdXN0b21WYWx1ZSgpO1xuICAgICAgICB9IGVsc2UgLy8gUmVzZXQgaW5wdXRWYWx1ZSBhbmQgY2xvc2UgbWVudVxuICAgICAgICBjb21taXRTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIGxldCBjb21taXQgPSAoKT0+e1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgaW5wdXRWYWx1ZSBhbmQgY2xvc2UgbWVudSBoZXJlIGlmIHRoZSBzZWxlY3RlZCBrZXkgaXMgYWxyZWFkeSB0aGUgZm9jdXNlZCBrZXkuIE90aGVyd2lzZVxuICAgICAgICAgICAgLy8gZmlyZSBvblNlbGVjdGlvbkNoYW5nZSB0byBhbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gY29udHJvbCB0aGUgY2xvc2luZy5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEtleSA9PT0gc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5KSBjb21taXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGVsc2Ugc2V0U2VsZWN0ZWRLZXkoc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5KTtcbiAgICAgICAgfSBlbHNlIGNvbW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBsZXQgdmFsdWVPbkZvY3VzID0gKDAsICRrNlBwdSR1c2VSZWYpKGlucHV0VmFsdWUpO1xuICAgIGxldCBzZXRGb2N1c2VkID0gKGlzRm9jdXNlZCk9PntcbiAgICAgICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgdmFsdWVPbkZvY3VzLmN1cnJlbnQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgaWYgKG1lbnVUcmlnZ2VyID09PSBcImZvY3VzXCIpIG9wZW4obnVsbCwgXCJmb2N1c1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZU9uQmx1cikgY29tbWl0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSB2YWx1ZU9uRm9jdXMuY3VycmVudCkgdmFsaWRhdGlvbi5jb21taXRWYWxpZGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Rm9jdXNlZFN0YXRlKGlzRm9jdXNlZCk7XG4gICAgfTtcbiAgICBsZXQgZGlzcGxheWVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgIGlmIChzaG93QWxsSXRlbXMpIHJldHVybiBvcmlnaW5hbENvbGxlY3Rpb247XG4gICAgICAgICAgICBlbHNlIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSByZXR1cm4gbGFzdENvbGxlY3Rpb247XG4gICAgfSwgW1xuICAgICAgICB0cmlnZ2VyU3RhdGUuaXNPcGVuLFxuICAgICAgICBvcmlnaW5hbENvbGxlY3Rpb24sXG4gICAgICAgIGZpbHRlcmVkQ29sbGVjdGlvbixcbiAgICAgICAgc2hvd0FsbEl0ZW1zLFxuICAgICAgICBsYXN0Q29sbGVjdGlvblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbGlkYXRpb24sXG4gICAgICAgIC4uLnRyaWdnZXJTdGF0ZSxcbiAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGUsXG4gICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgIGNsb3NlOiBjb21taXRWYWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5LFxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZCxcbiAgICAgICAgc2V0Rm9jdXNlZDogc2V0Rm9jdXNlZCxcbiAgICAgICAgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW0sXG4gICAgICAgIGNvbGxlY3Rpb246IGRpc3BsYXllZENvbGxlY3Rpb24sXG4gICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgIHNldElucHV0VmFsdWU6IHNldElucHV0VmFsdWUsXG4gICAgICAgIGNvbW1pdDogY29tbWl0LFxuICAgICAgICByZXZlcnQ6IHJldmVydFxuICAgIH07XG59XG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3ICgwLCAkazZQcHUkTGlzdENvbGxlY3Rpb24pKCRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCBjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBmaWx0ZXIpKTtcbn1cbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCBub2RlcywgaW5wdXRWYWx1ZSwgZmlsdGVyKSB7XG4gICAgbGV0IGZpbHRlcmVkTm9kZSA9IFtdO1xuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInNlY3Rpb25cIiAmJiBub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9ICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCAoMCwgJGs2UHB1JGdldENoaWxkTm9kZXMpKG5vZGUsIGNvbGxlY3Rpb24pLCBpbnB1dFZhbHVlLCBmaWx0ZXIpO1xuICAgICAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICAgICAuLi5maWx0ZXJlZFxuICAgICAgICAgICAgXS5zb21lKChub2RlKT0+bm9kZS50eXBlID09PSBcIml0ZW1cIikpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZpbHRlcmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiICYmIGZpbHRlcihub2RlLnRleHRWYWx1ZSwgaW5wdXRWYWx1ZSkpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSAhPT0gXCJpdGVtXCIpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZE5vZGU7XG59XG5cblxuXG5cbmV4cG9ydCB7JGE5ZTczODJhN2QxMTFjYjUkZXhwb3J0JGI0NTNhM2JmZDRhNWZhOWUgYXMgdXNlQ29tYm9Cb3hTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRzBJO0FBQzFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2ZsYWdzL2Rpc3QvaW1wb3J0Lm1qcz8zYmJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBsZXQgJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MgPSBmYWxzZTtcbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwKCkge1xuICAgICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2KCkge1xuICAgIHJldHVybiAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cztcbn1cblxuXG5leHBvcnQgeyRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwIGFzIGVuYWJsZVRhYmxlTmVzdGVkUm93cywgJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDFiMDBjYjE0YTk2MTk0ZTYgYXMgdGFibGVOZXN0ZWRSb3dzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTs7QUFFN007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnREFBb0IsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUxBQXlMO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOExBQThMO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLDBDQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQWlCO0FBQzVDLGtDQUFrQywwQ0FBYztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJDQUFlO0FBQ3JFLDREQUE0RCwyQ0FBZTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5Q0FBYTtBQUMxQyxvREFBb0QsMkNBQWU7QUFDbkUsd0JBQXdCLHlDQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQ0FBZTtBQUM3RCxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtrYTtBQUNsYSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mb3JtL2Rpc3QvaW1wb3J0Lm1qcz9kNDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlQ29udGV4dCBhcyAkamNJT3ckY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkamNJT3ckdXNlTWVtbywgdXNlQ29udGV4dCBhcyAkamNJT3ckdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJGpjSU93JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGpjSU93JHVzZVJlZiwgdXNlRWZmZWN0IGFzICRqY0lPdyR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMgPSB7XG4gICAgYmFkSW5wdXQ6IGZhbHNlLFxuICAgIGN1c3RvbUVycm9yOiBmYWxzZSxcbiAgICBwYXR0ZXJuTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHJhbmdlT3ZlcmZsb3c6IGZhbHNlLFxuICAgIHJhbmdlVW5kZXJmbG93OiBmYWxzZSxcbiAgICBzdGVwTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHRvb0xvbmc6IGZhbHNlLFxuICAgIHRvb1Nob3J0OiBmYWxzZSxcbiAgICB0eXBlTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHZhbHVlTWlzc2luZzogZmFsc2UsXG4gICAgdmFsaWQ6IHRydWVcbn07XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFID0ge1xuICAgIC4uLiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjLFxuICAgIGN1c3RvbUVycm9yOiB0cnVlLFxuICAgIHZhbGlkOiBmYWxzZVxufTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhID0ge1xuICAgIGlzSW52YWxpZDogZmFsc2UsXG4gICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjLFxuICAgIHZhbGlkYXRpb25FcnJvcnM6IFtdXG59O1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEgPSAoMCwgJGpjSU93JGNyZWF0ZUNvbnRleHQpKHt9KTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWIgPSBcIl9fZm9ybVZhbGlkYXRpb25TdGF0ZVwiICsgRGF0ZS5ub3coKTtcbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwKHByb3BzKSB7XG4gICAgLy8gUHJpdmF0ZSBwcm9wIGZvciBwYXJlbnQgY29tcG9uZW50cyB0byBwYXNzIHN0YXRlIHRvIGNoaWxkcmVuLlxuICAgIGlmIChwcm9wc1skZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViXSkge1xuICAgICAgICBsZXQgeyByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbiwgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLCB1cGRhdGVWYWxpZGF0aW9uOiB1cGRhdGVWYWxpZGF0aW9uLCByZXNldFZhbGlkYXRpb246IHJlc2V0VmFsaWRhdGlvbiwgY29tbWl0VmFsaWRhdGlvbjogY29tbWl0VmFsaWRhdGlvbiB9ID0gcHJvcHNbJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbixcbiAgICAgICAgICAgIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbixcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkYXRpb246IHVwZGF0ZVZhbGlkYXRpb24sXG4gICAgICAgICAgICByZXNldFZhbGlkYXRpb246IHJlc2V0VmFsaWRhdGlvbixcbiAgICAgICAgICAgIGNvbW1pdFZhbGlkYXRpb246IGNvbW1pdFZhbGlkYXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgcmV0dXJuICRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbChwcm9wcyk7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZUltcGwocHJvcHMpIHtcbiAgICBsZXQgeyBpc0ludmFsaWQ6IGlzSW52YWxpZCwgdmFsaWRhdGlvblN0YXRlOiB2YWxpZGF0aW9uU3RhdGUsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgYnVpbHRpblZhbGlkYXRpb246IGJ1aWx0aW5WYWxpZGF0aW9uLCB2YWxpZGF0ZTogdmFsaWRhdGUsIHZhbGlkYXRpb25CZWhhdmlvcjogdmFsaWRhdGlvbkJlaGF2aW9yID0gXCJhcmlhXCIgfSA9IHByb3BzO1xuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgaWYgKHZhbGlkYXRpb25TdGF0ZSkgaXNJbnZhbGlkIHx8IChpc0ludmFsaWQgPSB2YWxpZGF0aW9uU3RhdGUgPT09IFwiaW52YWxpZFwiKTtcbiAgICAvLyBJZiB0aGUgaXNJbnZhbGlkIHByb3AgaXMgdHJ1ZSwgdXBkYXRlIHZhbGlkYXRpb24gcmVzdWx0IGluIHJlYWx0aW1lIChjb250cm9sbGVkKS5cbiAgICBsZXQgY29udHJvbGxlZEVycm9yID0gaXNJbnZhbGlkID8ge1xuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IFtdLFxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURVxuICAgIH0gOiBudWxsO1xuICAgIC8vIFBlcmZvcm0gY3VzdG9tIGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXG4gICAgbGV0IGNsaWVudEVycm9yID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlKHZhbGlkYXRlLCB2YWx1ZSkpLCBbXG4gICAgICAgIHZhbGlkYXRlLFxuICAgICAgICB2YWx1ZVxuICAgIF0pO1xuICAgIGlmIChidWlsdGluVmFsaWRhdGlvbiA9PT0gbnVsbCB8fCBidWlsdGluVmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVpbHRpblZhbGlkYXRpb24udmFsaWRhdGlvbkRldGFpbHMudmFsaWQpIGJ1aWx0aW5WYWxpZGF0aW9uID0gbnVsbDtcbiAgICAvLyBHZXQgcmVsZXZhbnQgc2VydmVyIGVycm9ycyBmcm9tIHRoZSBmb3JtLlxuICAgIGxldCBzZXJ2ZXJFcnJvcnMgPSAoMCwgJGpjSU93JHVzZUNvbnRleHQpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExKTtcbiAgICBsZXQgc2VydmVyRXJyb3JNZXNzYWdlcyA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PntcbiAgICAgICAgaWYgKG5hbWUpIHJldHVybiBBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZS5mbGF0TWFwKChuYW1lKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoc2VydmVyRXJyb3JzW25hbWVdKSkgOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShzZXJ2ZXJFcnJvcnNbbmFtZV0pO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSwgW1xuICAgICAgICBzZXJ2ZXJFcnJvcnMsXG4gICAgICAgIG5hbWVcbiAgICBdKTtcbiAgICAvLyBTaG93IHNlcnZlciBlcnJvcnMgd2hlbiB0aGUgZm9ybSBnZXRzIGEgbmV3IHZhbHVlLCBhbmQgY2xlYXIgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSB2YWx1ZS5cbiAgICBsZXQgW2xhc3RTZXJ2ZXJFcnJvcnMsIHNldExhc3RTZXJ2ZXJFcnJvcnNdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoc2VydmVyRXJyb3JzKTtcbiAgICBsZXQgW2lzU2VydmVyRXJyb3JDbGVhcmVkLCBzZXRTZXJ2ZXJFcnJvckNsZWFyZWRdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGlmIChzZXJ2ZXJFcnJvcnMgIT09IGxhc3RTZXJ2ZXJFcnJvcnMpIHtcbiAgICAgICAgc2V0TGFzdFNlcnZlckVycm9ycyhzZXJ2ZXJFcnJvcnMpO1xuICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQoZmFsc2UpO1xuICAgIH1cbiAgICBsZXQgc2VydmVyRXJyb3IgPSAoMCwgJGpjSU93JHVzZU1lbW8pKCgpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdChpc1NlcnZlckVycm9yQ2xlYXJlZCA/IFtdIDogc2VydmVyRXJyb3JNZXNzYWdlcyksIFtcbiAgICAgICAgaXNTZXJ2ZXJFcnJvckNsZWFyZWQsXG4gICAgICAgIHNlcnZlckVycm9yTWVzc2FnZXNcbiAgICBdKTtcbiAgICAvLyBUcmFjayB0aGUgbmV4dCB2YWxpZGF0aW9uIHN0YXRlIGluIGEgcmVmIHVudGlsIGNvbW1pdFZhbGlkYXRpb24gaXMgY2FsbGVkLlxuICAgIGxldCBuZXh0VmFsaWRhdGlvbiA9ICgwLCAkamNJT3ckdXNlUmVmKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IFtjdXJyZW50VmFsaWRpdHksIHNldEN1cnJlbnRWYWxpZGl0eV0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IGxhc3RFcnJvciA9ICgwLCAkamNJT3ckdXNlUmVmKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IGNvbW1pdFZhbGlkYXRpb24gPSAoKT0+e1xuICAgICAgICBpZiAoIWNvbW1pdFF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBzZXRDb21taXRRdWV1ZWQoZmFsc2UpO1xuICAgICAgICBsZXQgZXJyb3IgPSBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCBuZXh0VmFsaWRhdGlvbi5jdXJyZW50O1xuICAgICAgICBpZiAoISRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihlcnJvciwgbGFzdEVycm9yLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xuICAgICAgICAgICAgc2V0Q3VycmVudFZhbGlkaXR5KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IFtjb21taXRRdWV1ZWQsIHNldENvbW1pdFF1ZXVlZF0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgKDAsICRqY0lPdyR1c2VFZmZlY3QpKGNvbW1pdFZhbGlkYXRpb24pO1xuICAgIC8vIHJlYWx0aW1lVmFsaWRhdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQncyBzdGF0ZSBiYXNlZCBvbiBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYy5cbiAgICAvLyBkaXNwbGF5VmFsaWRhdGlvbiBpcyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB2YWxpZGF0aW9uIHN0YXRlIHRoYXQgdGhlIHVzZXIgc2VlcyAoZS5nLiBvbiBpbnB1dCBjaGFuZ2UvZm9ybSBzdWJtaXQpLlxuICAgIC8vIFdpdGggdmFsaWRhdGlvbkJlaGF2aW9yPVwiYXJpYVwiLCBhbGwgZXJyb3JzIGFyZSBkaXNwbGF5ZWQgaW4gcmVhbHRpbWUgcmF0aGVyIHRoYW4gb24gc3VibWl0LlxuICAgIGxldCByZWFsdGltZVZhbGlkYXRpb24gPSBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY2xpZW50RXJyb3IgfHwgYnVpbHRpblZhbGlkYXRpb24gfHwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmE7XG4gICAgbGV0IGRpc3BsYXlWYWxpZGF0aW9uID0gdmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiID8gY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGN1cnJlbnRWYWxpZGl0eSA6IGNvbnRyb2xsZWRFcnJvciB8fCBzZXJ2ZXJFcnJvciB8fCBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCBjdXJyZW50VmFsaWRpdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sXG4gICAgICAgIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbixcbiAgICAgICAgdXBkYXRlVmFsaWRhdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHZhbGlkYXRpb25CZWhhdmlvciBpcyAnYXJpYScsIHVwZGF0ZSBpbiByZWFsdGltZS4gT3RoZXJ3aXNlLCBzdG9yZSBpbiBhIHJlZiB1bnRpbCBjb21taXQuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcImFyaWFcIiAmJiAhJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGN1cnJlbnRWYWxpZGl0eSwgdmFsdWUpKSBzZXRDdXJyZW50VmFsaWRpdHkodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBuZXh0VmFsaWRhdGlvbi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0VmFsaWRhdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdmFsaWRhdGlvbiBzdGF0ZSB0byB2YWxpZCBvbiBmb3JtIHJlc2V0LFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgbmF0aXZlIHZhbGlkaXR5IHNheXMgaXQgaXNuJ3QuIEl0J2xsIHNob3cgYWdhaW4gb24gdGhlIG5leHQgZm9ybSBzdWJtaXQuXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YTtcbiAgICAgICAgICAgIGlmICghJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGVycm9yLCBsYXN0RXJyb3IuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRWYWxpZGl0eShlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgY29tbWl0IHZhbGlkYXRpb24gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLiBUaGlzIGF2b2lkcyBhIGNvbmRpdGlvbiB3aGVyZVxuICAgICAgICAgICAgLy8gdXNlU2VsZWN0IGNhbGxzIGNvbW1pdFZhbGlkYXRpb24gaW5zaWRlIGFuIG9uUmVzZXQgaGFuZGxlci5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIpIHNldENvbW1pdFF1ZXVlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFZhbGlkYXRpb24gKCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHZhbGlkYXRpb24gc3RhdGUgc28gdGhlIHVzZXIgc2VlcyBpdCBvbiBibHVyL2NoYW5nZS9zdWJtaXQuIEFsc28gY2xlYXIgYW55IHNlcnZlciBlcnJvcnMuXG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGFmdGVyIHRoZSBuZXh0IHJlbmRlciB0byBjb21taXQgc28gdGhhdCB0aGUgbGF0ZXN0IHZhbHVlIGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIpIHNldENvbW1pdFF1ZXVlZCh0cnVlKTtcbiAgICAgICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheSh2KSB7XG4gICAgaWYgKCF2KSByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2IDogW1xuICAgICAgICB2XG4gICAgXTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRydW5WYWxpZGF0ZSh2YWxpZGF0ZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGV0IGUgPSB2YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChlICYmIHR5cGVvZiBlICE9PSBcImJvb2xlYW5cIikgcmV0dXJuICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KGUpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdChlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IHtcbiAgICAgICAgaXNJbnZhbGlkOiB0cnVlLFxuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFXG4gICAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYSAmJiBiICYmIGEuaXNJbnZhbGlkID09PSBiLmlzSW52YWxpZCAmJiBhLnZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID09PSBiLnZhbGlkYXRpb25FcnJvcnMubGVuZ3RoICYmIGEudmFsaWRhdGlvbkVycm9ycy5ldmVyeSgoYSwgaSk9PmEgPT09IGIudmFsaWRhdGlvbkVycm9yc1tpXSkgJiYgT2JqZWN0LmVudHJpZXMoYS52YWxpZGF0aW9uRGV0YWlscykuZXZlcnkoKFtrLCB2XSk9PmIudmFsaWRhdGlvbkRldGFpbHNba10gPT09IHYpO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUoLi4ucmVzdWx0cykge1xuICAgIGxldCBlcnJvcnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgIGxldCB2YWxpZGF0aW9uRGV0YWlscyA9IHtcbiAgICAgICAgLi4uJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmNcbiAgICB9O1xuICAgIGZvciAobGV0IHYgb2YgcmVzdWx0cyl7XG4gICAgICAgIHZhciBfdmFsaWRhdGlvbkRldGFpbHMsIF9rZXk7XG4gICAgICAgIGZvciAobGV0IGUgb2Ygdi52YWxpZGF0aW9uRXJyb3JzKWVycm9ycy5hZGQoZSk7XG4gICAgICAgIC8vIE9ubHkgdGhlc2UgcHJvcGVydGllcyBhcHBseSBmb3IgY2hlY2tib3hlcy5cbiAgICAgICAgaXNJbnZhbGlkIHx8IChpc0ludmFsaWQgPSB2LmlzSW52YWxpZCk7XG4gICAgICAgIGZvcihsZXQga2V5IGluIHZhbGlkYXRpb25EZXRhaWxzKShfdmFsaWRhdGlvbkRldGFpbHMgPSB2YWxpZGF0aW9uRGV0YWlscylbX2tleSA9IGtleV0gfHwgKF92YWxpZGF0aW9uRGV0YWlsc1tfa2V5XSA9IHYudmFsaWRhdGlvbkRldGFpbHNba2V5XSk7XG4gICAgfVxuICAgIHZhbGlkYXRpb25EZXRhaWxzLnZhbGlkID0gIWlzSW52YWxpZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ludmFsaWQ6IGlzSW52YWxpZCxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogW1xuICAgICAgICAgICAgLi4uZXJyb3JzXG4gICAgICAgIF0sXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiB2YWxpZGF0aW9uRGV0YWlsc1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEgYXMgRm9ybVZhbGlkYXRpb25Db250ZXh0LCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMCBhcyB1c2VGb3JtVmFsaWRhdGlvblN0YXRlLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSBhcyBERUZBVUxUX1ZBTElEQVRJT05fUkVTVUxULCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyBhcyBWQUxJRF9WQUxJRElUWV9TVEFURSwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiBhcyBwcml2YXRlVmFsaWRhdGlvblN0YXRlUHJvcCwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUgYXMgbWVyZ2VWYWxpZGF0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row\n                child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1Qzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxVQUFVLCtDQUErQztBQUN6RCw2QkFBNkIsK0VBQWdDO0FBQzdELDJCQUEyQiwwQ0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQW9CO0FBQ3ZELGdFQUFnRSxtRUFBa0I7QUFDbEYsZ0RBQWdELG9FQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBYyxjQUFjLHNFQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5Q0FBYTtBQUM5QyxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxRUFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7OztBQUsrSDtBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9ncmlkL2Rpc3QvaW1wb3J0Lm1qcz8xNzc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0Q2hpbGROb2RlcyBhcyAkY0FuNWYkZ2V0Q2hpbGROb2RlcywgZ2V0TGFzdEl0ZW0gYXMgJGNBbjVmJGdldExhc3RJdGVtLCBnZXRGaXJzdEl0ZW0gYXMgJGNBbjVmJGdldEZpcnN0SXRlbX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUgYXMgJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsIFNlbGVjdGlvbk1hbmFnZXIgYXMgJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb25cIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkY0FuNWYkdXNlTWVtbywgdXNlUmVmIGFzICRjQW41ZiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkY0FuNWYkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkKHByb3BzKSB7XG4gICAgbGV0IHsgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgZm9jdXNNb2RlOiBmb2N1c01vZGUgfSA9IHByb3BzO1xuICAgIGxldCBzZWxlY3Rpb25TdGF0ZSA9ICgwLCAkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSkocHJvcHMpO1xuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJGNBbjVmJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IHNldEZvY3VzZWRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5O1xuICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkgPSAoa2V5LCBjaGlsZCk9PntcbiAgICAgICAgLy8gSWYgZm9jdXNNb2RlIGlzIGNlbGwgYW5kIGFuIGl0ZW0gaXMgZm9jdXNlZCwgZm9jdXMgYSBjaGlsZCBjZWxsIGluc3RlYWQuXG4gICAgICAgIGlmIChmb2N1c01vZGUgPT09IFwiY2VsbFwiICYmIGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0udHlwZSkgPT09IFwiaXRlbVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRMYXN0SXRlbSwgX2dldEZpcnN0SXRlbTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSAoMCwgJGNBbjVmJGdldENoaWxkTm9kZXMpKGl0ZW0sIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gXCJsYXN0XCIpIGtleSA9IChfZ2V0TGFzdEl0ZW0gPSAoMCwgJGNBbjVmJGdldExhc3RJdGVtKShjaGlsZHJlbikpID09PSBudWxsIHx8IF9nZXRMYXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldExhc3RJdGVtLmtleTtcbiAgICAgICAgICAgICAgICBlbHNlIGtleSA9IChfZ2V0Rmlyc3RJdGVtID0gKDAsICRjQW41ZiRnZXRGaXJzdEl0ZW0pKGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkKTtcbiAgICB9O1xuICAgIGxldCBzZWxlY3Rpb25NYW5hZ2VyID0gKDAsICRjQW41ZiR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkY0FuNWYkU2VsZWN0aW9uTWFuYWdlcikoY29sbGVjdGlvbiwgc2VsZWN0aW9uU3RhdGUpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvblN0YXRlXG4gICAgXSk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBjb25zdCBjYWNoZWRDb2xsZWN0aW9uID0gKDAsICRjQW41ZiR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkY0FuNWYkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEtleSAhPSBudWxsICYmIChub2RlLnR5cGUgPT09IFwiY2VsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJyb3doZWFkZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiY29sdW1uXCIpID8gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpIDogbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJvd3MgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQucm93cztcbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBjb2xsZWN0aW9uLnJvd3M7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY2FjaGVkUm93cy5sZW5ndGggLSByb3dzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKGRpZmYgPiAxID8gTWF0aC5tYXgocGFyZW50Tm9kZS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHBhcmVudE5vZGUuaW5kZXgsIHJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgbmV3Um93O1xuICAgICAgICAgICAgd2hpbGUoaW5kZXggPj0gMCl7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25NYW5hZ2VyLmlzRGlzYWJsZWQocm93c1tpbmRleF0ua2V5KSAmJiByb3dzW2luZGV4XS50eXBlICE9PSBcImhlYWRlcnJvd1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IHJvd3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCBuZXh0LCBub3QgZGlzYWJsZWQgcm93LlxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHJvd3MubGVuZ3RoIC0gMSkgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50Tm9kZS5pbmRleCkgaW5kZXggPSBwYXJlbnROb2RlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdSb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLigwLCAkY0FuNWYkZ2V0Q2hpbGROb2RlcykobmV3Um93LCBjb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlUb0ZvY3VzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSAhPT0gbm9kZSAmJiBub2RlLmluZGV4IDwgY2hpbGROb2Rlcy5sZW5ndGggPyBjaGlsZE5vZGVzW25vZGUuaW5kZXhdLmtleSA6IG5ld1Jvdy5rZXk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShrZXlUb0ZvY3VzKTtcbiAgICAgICAgICAgIH0gZWxzZSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlZENvbGxlY3Rpb24uY3VycmVudCA9IGNvbGxlY3Rpb247XG4gICAgfSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZSxcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlclxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2Qge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICB2YXIgXztcbiAgICAgICAgcmV0dXJuIChfID0gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF1bMF0pID09PSBudWxsIHx8IF8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF8ua2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICB2YXIgX3Jvd3NfO1xuICAgICAgICBsZXQgcm93cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKF9yb3dzXyA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX3Jvd3NfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm93c18ua2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2hpbGROb2RlcykgfHwgW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY29sdW1uQ291bnQ7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgcHJldmlvdXMgbm9kZSBmb3IgdGhlIHNhbWUga2V5LFxuICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFdlIGFsd2F5cyB2aXNpdCBjb2x1bW5zIHRob3VnaCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZGVwZW5kIG9uIG9yZGVyIHRvIGJ1aWxkIHRoZSBjb2x1bW5zIGFycmF5LlxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gdGhpcy5rZXlNYXAuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZpc2l0Tm9kZSkgbm9kZSA9IG9wdHMudmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiICYmIGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgICAgICBjaGlsZEtleXMuYWRkKGNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkZWxldGVkIG5vZGVzIGFuZCB0aGVpciBjaGlsZHJlbiBmcm9tIHRoZSBrZXkgbWFwXG4gICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBwcmV2Tm9kZS5jaGlsZE5vZGVzKWlmICghY2hpbGRLZXlzLmhhcyhjaGlsZC5rZXkpKSByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVtb3ZlID0gKG5vZGUpPT57XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICh0aGlzLmtleU1hcC5nZXQoY2hpbGQua2V5KSA9PT0gY2hpbGQpIHJlbW92ZShjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBvcHRzLml0ZW1zLmZvckVhY2goKG5vZGUsIGkpPT57XG4gICAgICAgICAgICBsZXQgcm93Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBrZXk6IFwicm93LVwiICsgaSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJvd1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi5ub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSByb3dOb2RlLmtleTtcbiAgICAgICAgICAgICAgICByb3dOb2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgIH0gZWxzZSByb3dOb2RlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICB2aXNpdChyb3dOb2RlKTtcbiAgICAgICAgICAgIGxhc3QgPSByb3dOb2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhc3QpIGxhc3QubmV4dEtleSA9IG51bGw7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkIGFzIHVzZUdyaWRTdGF0ZSwgJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCBhcyBHcmlkQ29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\n\n\n\n\n\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSjtBQUNUO0FBQzFEO0FBQ0k7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0IsNkJBQTZCLCtFQUFnQztBQUM3RCwyQkFBMkIsMENBQWM7QUFDekM7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBa0I7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBYztBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHFFQUFvQjtBQUM3QywrQkFBK0IsMENBQWMsY0FBYyxzRUFBdUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQWE7QUFDOUMsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRDQUE0QyxvRUFBeUI7QUFDckUsMkJBQTJCLDBDQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5RkFBeUY7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU11TTtBQUN2TSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9saXN0L2Rpc3QvaW1wb3J0Lm1qcz81ZDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkNThQaHMkU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICQ1OFBocyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkNThQaHMkdXNlQ2FsbGJhY2ssIHVzZVJlZiBhcyAkNThQaHMkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDU4UGhzJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbGxlY3Rpb24gYXMgJDU4UGhzJHVzZUNvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDU4UGhzJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3IHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLml0ZXJhYmxlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLnNpemU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RLZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RLZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iobm9kZXMpe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUudHlwZSA9PT0gXCJzZWN0aW9uXCIpIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpdmlzaXQobm9kZSk7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBba2V5LCBub2RlXSBvZiB0aGlzLmtleU1hcCl7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikgbm9kZS5pbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIFNldCBuZXh0S2V5IGFzIHVuZGVmaW5lZCBzaW5jZSB0aGlzIG1pZ2h0IGJlIHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IHRoZSBsYXN0IG5vZGUsIGxhc3QubmV4dEtleSB3aWxsIHByb3Blcmx5IHNldCBhdCBzdGFydCBvZiBuZXcgbG9vcFxuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEtleSA9IGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XG4gICAgfVxufVxuXG5cblxuXG5cbmZ1bmN0aW9uICRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0KHByb3BzKSB7XG4gICAgbGV0IHsgZmlsdGVyOiBmaWx0ZXIgfSA9IHByb3BzO1xuICAgIGxldCBzZWxlY3Rpb25TdGF0ZSA9ICgwLCAkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSkocHJvcHMpO1xuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IGZhY3RvcnkgPSAoMCwgJDU4UGhzJHVzZUNhbGxiYWNrKSgobm9kZXMpPT5maWx0ZXIgPyBuZXcgKDAsICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3KShmaWx0ZXIobm9kZXMpKSA6IG5ldyAoMCwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcpKG5vZGVzKSwgW1xuICAgICAgICBmaWx0ZXJcbiAgICBdKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHByb3BzLnN1cHByZXNzVGV4dFZhbHVlV2FybmluZ1xuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmdcbiAgICBdKTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkNThQaHMkdXNlQ29sbGVjdGlvbikocHJvcHMsIGZhY3RvcnksIGNvbnRleHQpO1xuICAgIGxldCBzZWxlY3Rpb25NYW5hZ2VyID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkNThQaHMkU2VsZWN0aW9uTWFuYWdlcikoY29sbGVjdGlvbiwgc2VsZWN0aW9uU3RhdGUpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvblN0YXRlXG4gICAgXSk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBjb25zdCBjYWNoZWRDb2xsZWN0aW9uID0gKDAsICQ1OFBocyR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkNThQaHMkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SXRlbSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkSXRlbU5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRLZXlzKClcbiAgICAgICAgICAgIF0ubWFwKChrZXkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTm9kZS50eXBlID09PSBcIml0ZW1cIiA/IGl0ZW1Ob2RlIDogbnVsbDtcbiAgICAgICAgICAgIH0pLmZpbHRlcigobm9kZSk9Pm5vZGUgIT09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXRlbU5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24uZ2V0S2V5cygpXG4gICAgICAgICAgICBdLm1hcCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ob2RlLnR5cGUgPT09IFwiaXRlbVwiID8gaXRlbU5vZGUgOiBudWxsO1xuICAgICAgICAgICAgfSkuZmlsdGVyKChub2RlKT0+bm9kZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY2FjaGVkSXRlbU5vZGVzLmxlbmd0aCAtIGl0ZW1Ob2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihkaWZmID4gMSA/IE1hdGgubWF4KHN0YXJ0SXRlbS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHN0YXJ0SXRlbS5pbmRleCwgaXRlbU5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IG5ld05vZGU7XG4gICAgICAgICAgICB3aGlsZShpbmRleCA+PSAwKXtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbk1hbmFnZXIuaXNEaXNhYmxlZChpdGVtTm9kZXNbaW5kZXhdLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IGl0ZW1Ob2Rlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQsIG5vdCBkaXNhYmxlZCBpdGVtLlxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGl0ZW1Ob2Rlcy5sZW5ndGggLSAxKSBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBzdGFydEl0ZW0uaW5kZXgpIGluZGV4ID0gc3RhcnRJdGVtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobmV3Tm9kZSA/IG5ld05vZGUua2V5IDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbjtcbiAgICB9LCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXJcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkYTBkNjQ1Mjg5ZmU5Yjg2YiRleHBvcnQkZTdmMDVlOTg1ZGFmNGI1Zihwcm9wcykge1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xuICAgIGxldCBbc2VsZWN0ZWRLZXksIHNldFNlbGVjdGVkS2V5XSA9ICgwLCAkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5zZWxlY3RlZEtleSwgKF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgPSBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgOiBudWxsLCBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgbGV0IHNlbGVjdGVkS2V5cyA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9PnNlbGVjdGVkS2V5ICE9IG51bGwgPyBbXG4gICAgICAgICAgICBzZWxlY3RlZEtleVxuICAgICAgICBdIDogW10sIFtcbiAgICAgICAgc2VsZWN0ZWRLZXlcbiAgICBdKTtcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cywgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciB9ID0gKDAsICRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0KSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICBhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiAoa2V5cyk9PntcbiAgICAgICAgICAgIHZhciBfa2V5c192YWx1ZXNfbmV4dF92YWx1ZTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX2tleXNfdmFsdWVzX25leHRfdmFsdWUgPSBrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkgIT09IG51bGwgJiYgX2tleXNfdmFsdWVzX25leHRfdmFsdWUgIT09IHZvaWQgMCA/IF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBmaXJlIG9uU2VsZWN0aW9uQ2hhbmdlLCBldmVuIGlmIHRoZSBrZXkgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGFzIHRoZSBjdXJyZW50IGtleSAodXNlQ29udHJvbGxlZFN0YXRlIGRvZXMgbm90KS5cbiAgICAgICAgICAgIGlmIChrZXkgPT09IHNlbGVjdGVkS2V5ICYmIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRLZXkoa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBzZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZEtleSAhPSBudWxsID8gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXk6IHNldFNlbGVjdGVkS2V5LFxuICAgICAgICBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbVxuICAgIH07XG59XG5cblxuXG5cblxuZXhwb3J0IHskZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NCBhcyB1c2VMaXN0U3RhdGUsICRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmIGFzIHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcgYXMgTGlzdENvbGxlY3Rpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_useSubmenuTriggerState: () => (/* binding */ $e5614764aa47eb35$export$d39fdbfa42246ac4),\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [expandedKeysStack, setExpandedKeysStack] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let closeAll = ()=>{\n        setExpandedKeysStack([]);\n        overlayTriggerState.close();\n    };\n    let openSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            if (level > oldStack.length) return oldStack;\n            return [\n                ...oldStack.slice(0, level),\n                triggerKey\n            ];\n        });\n    };\n    let closeSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            let key = oldStack[level];\n            if (key === triggerKey) return oldStack.slice(0, level);\n            else return oldStack;\n        });\n    };\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        },\n        close () {\n            closeAll();\n        },\n        UNSTABLE_expandedKeysStack: expandedKeysStack,\n        UNSTABLE_openSubmenu: openSubmenu,\n        UNSTABLE_closeSubmenu: closeSubmenu\n    };\n}\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $e5614764aa47eb35$export$d39fdbfa42246ac4(props, state) {\n    let { triggerKey: triggerKey } = props;\n    let { UNSTABLE_expandedKeysStack: UNSTABLE_expandedKeysStack, UNSTABLE_openSubmenu: UNSTABLE_openSubmenu, UNSTABLE_closeSubmenu: UNSTABLE_closeSubmenu, close: closeAll } = state;\n    let [submenuLevel] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNSTABLE_expandedKeysStack === null || UNSTABLE_expandedKeysStack === void 0 ? void 0 : UNSTABLE_expandedKeysStack.length);\n    let isOpen = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>UNSTABLE_expandedKeysStack[submenuLevel] === triggerKey, [\n        UNSTABLE_expandedKeysStack,\n        triggerKey,\n        submenuLevel\n    ]);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        UNSTABLE_openSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_openSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFocusStrategy(null);\n        UNSTABLE_closeSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_closeSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        if (isOpen) close();\n        else open(focusStrategy);\n    }, [\n        close,\n        open,\n        isOpen\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusStrategy: focusStrategy,\n            isOpen: isOpen,\n            open: open,\n            close: close,\n            closeAll: closeAll,\n            submenuLevel: submenuLevel,\n            // TODO: Placeholders that aren't used but give us parity with OverlayTriggerState so we can use this in Popover. Refactor if we update Popover via\n            // https://github.com/adobe/react-spectrum/pull/4976#discussion_r1336472863\n            setOpen: ()=>{},\n            toggle: toggle\n        }), [\n        isOpen,\n        open,\n        close,\n        closeAll,\n        focusStrategy,\n        toggle,\n        submenuLevel\n    ]);\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNnQjs7QUFFaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLDJFQUE2QjtBQUMvRCxnREFBZ0QsMkNBQWU7QUFDL0Qsd0RBQXdELDJDQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFVBQVUsb0tBQW9LO0FBQzlLLDZCQUE2QiwyQ0FBZTtBQUM1QyxxQkFBcUIsMENBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQWU7QUFDL0QsbUJBQW1CLDhDQUFrQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFrQjtBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUt3SjtBQUN4SiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9tZW51L2Rpc3QvaW1wb3J0Lm1qcz9lMTdjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkOVh2b2gkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5pbXBvcnQge3VzZVN0YXRlIGFzICQ5WHZvaCR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOVh2b2gkdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDlYdm9oJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMocHJvcHMpIHtcbiAgICBsZXQgb3ZlcmxheVRyaWdnZXJTdGF0ZSA9ICgwLCAkOVh2b2gkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgW2V4cGFuZGVkS2V5c1N0YWNrLCBzZXRFeHBhbmRlZEtleXNTdGFja10gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShbXSk7XG4gICAgbGV0IGNsb3NlQWxsID0gKCk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzU3RhY2soW10pO1xuICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLmNsb3NlKCk7XG4gICAgfTtcbiAgICBsZXQgb3BlblN1Ym1lbnUgPSAodHJpZ2dlcktleSwgbGV2ZWwpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKChvbGRTdGFjayk9PntcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IG9sZFN0YWNrLmxlbmd0aCkgcmV0dXJuIG9sZFN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5vbGRTdGFjay5zbGljZSgwLCBsZXZlbCksXG4gICAgICAgICAgICAgICAgdHJpZ2dlcktleVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgY2xvc2VTdWJtZW51ID0gKHRyaWdnZXJLZXksIGxldmVsKT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXNTdGFjaygob2xkU3RhY2spPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gb2xkU3RhY2tbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdHJpZ2dlcktleSkgcmV0dXJuIG9sZFN0YWNrLnNsaWNlKDAsIGxldmVsKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIG9sZFN0YWNrO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzU3RyYXRlZ3k6IGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIC4uLm92ZXJsYXlUcmlnZ2VyU3RhdGUsXG4gICAgICAgIG9wZW4gKGZvY3VzU3RyYXRlZ3kgPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgb3ZlcmxheVRyaWdnZXJTdGF0ZS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZSAoZm9jdXNTdHJhdGVneSA9IG51bGwpIHtcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLnRvZ2dsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZSAoKSB7XG4gICAgICAgICAgICBjbG9zZUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjazogZXhwYW5kZWRLZXlzU3RhY2ssXG4gICAgICAgIFVOU1RBQkxFX29wZW5TdWJtZW51OiBvcGVuU3VibWVudSxcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51OiBjbG9zZVN1Ym1lbnVcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRlNTYxNDc2NGFhNDdlYjM1JGV4cG9ydCRkMzlmZGJmYTQyMjQ2YWM0KHByb3BzLCBzdGF0ZSkge1xuICAgIGxldCB7IHRyaWdnZXJLZXk6IHRyaWdnZXJLZXkgfSA9IHByb3BzO1xuICAgIGxldCB7IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrOiBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjaywgVU5TVEFCTEVfb3BlblN1Ym1lbnU6IFVOU1RBQkxFX29wZW5TdWJtZW51LCBVTlNUQUJMRV9jbG9zZVN1Ym1lbnU6IFVOU1RBQkxFX2Nsb3NlU3VibWVudSwgY2xvc2U6IGNsb3NlQWxsIH0gPSBzdGF0ZTtcbiAgICBsZXQgW3N1Ym1lbnVMZXZlbF0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayA9PT0gbnVsbCB8fCBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2subGVuZ3RoKTtcbiAgICBsZXQgaXNPcGVuID0gKDAsICQ5WHZvaCR1c2VNZW1vKSgoKT0+VU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2tbc3VibWVudUxldmVsXSA9PT0gdHJpZ2dlcktleSwgW1xuICAgICAgICBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayxcbiAgICAgICAgdHJpZ2dlcktleSxcbiAgICAgICAgc3VibWVudUxldmVsXG4gICAgXSk7XG4gICAgbGV0IFtmb2N1c1N0cmF0ZWd5LCBzZXRGb2N1c1N0cmF0ZWd5XSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBvcGVuID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICBVTlNUQUJMRV9vcGVuU3VibWVudSh0cmlnZ2VyS2V5LCBzdWJtZW51TGV2ZWwpO1xuICAgIH0sIFtcbiAgICAgICAgVU5TVEFCTEVfb3BlblN1Ym1lbnUsXG4gICAgICAgIHN1Ym1lbnVMZXZlbCxcbiAgICAgICAgdHJpZ2dlcktleVxuICAgIF0pO1xuICAgIGxldCBjbG9zZSA9ICgwLCAkOVh2b2gkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3kobnVsbCk7XG4gICAgICAgIFVOU1RBQkxFX2Nsb3NlU3VibWVudSh0cmlnZ2VyS2V5LCBzdWJtZW51TGV2ZWwpO1xuICAgIH0sIFtcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51LFxuICAgICAgICBzdWJtZW51TGV2ZWwsXG4gICAgICAgIHRyaWdnZXJLZXlcbiAgICBdKTtcbiAgICBsZXQgdG9nZ2xlID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICBpZiAoaXNPcGVuKSBjbG9zZSgpO1xuICAgICAgICBlbHNlIG9wZW4oZm9jdXNTdHJhdGVneSk7XG4gICAgfSwgW1xuICAgICAgICBjbG9zZSxcbiAgICAgICAgb3BlbixcbiAgICAgICAgaXNPcGVuXG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkOVh2b2gkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBmb2N1c1N0cmF0ZWd5OiBmb2N1c1N0cmF0ZWd5LFxuICAgICAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgY2xvc2VBbGw6IGNsb3NlQWxsLFxuICAgICAgICAgICAgc3VibWVudUxldmVsOiBzdWJtZW51TGV2ZWwsXG4gICAgICAgICAgICAvLyBUT0RPOiBQbGFjZWhvbGRlcnMgdGhhdCBhcmVuJ3QgdXNlZCBidXQgZ2l2ZSB1cyBwYXJpdHkgd2l0aCBPdmVybGF5VHJpZ2dlclN0YXRlIHNvIHdlIGNhbiB1c2UgdGhpcyBpbiBQb3BvdmVyLiBSZWZhY3RvciBpZiB3ZSB1cGRhdGUgUG9wb3ZlciB2aWFcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9wdWxsLzQ5NzYjZGlzY3Vzc2lvbl9yMTMzNjQ3Mjg2M1xuICAgICAgICAgICAgc2V0T3BlbjogKCk9Pnt9LFxuICAgICAgICAgICAgdG9nZ2xlOiB0b2dnbGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICBvcGVuLFxuICAgICAgICBjbG9zZSxcbiAgICAgICAgY2xvc2VBbGwsXG4gICAgICAgIGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIHRvZ2dsZSxcbiAgICAgICAgc3VibWVudUxldmVsXG4gICAgXSk7XG59XG5cblxuXG5cbmV4cG9ydCB7JGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMgYXMgdXNlTWVudVRyaWdnZXJTdGF0ZSwgJGU1NjE0NzY0YWE0N2ViMzUkZXhwb3J0JGQzOWZkYmZhNDIyNDZhYzQgYXMgVU5TVEFCTEVfdXNlU3VibWVudVRyaWdnZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2Qjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG9FQUF5QjtBQUN6RCxxQkFBcUIsOENBQWtCO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsOENBQWtCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsOENBQWtCO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSzZFO0FBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcz8xMGIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ2FsbGJhY2sgYXMgJDRvQTNQJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNihwcm9wcykge1xuICAgIGxldCBbaXNPcGVuLCBzZXRPcGVuXSA9ICgwLCAkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pc09wZW4sIHByb3BzLmRlZmF1bHRPcGVuIHx8IGZhbHNlLCBwcm9wcy5vbk9wZW5DaGFuZ2UpO1xuICAgIGNvbnN0IG9wZW4gPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRPcGVuKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlblxuICAgIF0pO1xuICAgIGNvbnN0IGNsb3NlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuXG4gICAgXSk7XG4gICAgY29uc3QgdG9nZ2xlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbighaXNPcGVuKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW4sXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICBzZXRPcGVuOiBzZXRPcGVuLFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiBhcyB1c2VPdmVybGF5VHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nlet $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    var _props_defaultValue;\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValue\n    });\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) {\n            setSelected(value);\n            validation.commitValidation();\n        }\n    };\n    let isInvalid = validation.displayValidation.isInvalid;\n    return {\n        ...validation,\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || (isInvalid ? \"invalid\" : null),\n        isInvalid: isInvalid\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEY7QUFDUDtBQUNSOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFjLG1DQUFtQywrQkFBK0IsR0FBRywwQkFBMEI7QUFDaEk7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9FQUF5QjtBQUNwRSxzREFBc0QsMkNBQWU7QUFDckUseUJBQXlCLHVFQUE2QjtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLeUU7QUFDekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzP2NmM2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGZRMlNGJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGZRMlNGJHVzZU1lbW8sIHVzZVN0YXRlIGFzICRmUTJTRiR1c2VTdGF0ZX0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcbmxldCAkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaSA9IDA7XG5mdW5jdGlvbiAkYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYihwcm9wcykge1xuICAgIC8vIFByZXNlcnZlZCBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBSZWFjdCBBcmlhIG5vdyBnZW5lcmF0ZXMgdGhlIG5hbWUgaW5zdGVhZCBvZiBzdGF0ZWx5LlxuICAgIGxldCBuYW1lID0gKDAsICRmUTJTRiR1c2VNZW1vKSgoKT0+cHJvcHMubmFtZSB8fCBgcmFkaW8tZ3JvdXAtJHskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2V9LSR7KyskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaX1gLCBbXG4gICAgICAgIHByb3BzLm5hbWVcbiAgICBdKTtcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRWYWx1ZTtcbiAgICBsZXQgW3NlbGVjdGVkVmFsdWUsIHNldFNlbGVjdGVkXSA9ICgwLCAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy52YWx1ZSwgKF9wcm9wc19kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0VmFsdWUgOiBudWxsLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IFtsYXN0Rm9jdXNlZFZhbHVlLCBzZXRMYXN0Rm9jdXNlZFZhbHVlXSA9ICgwLCAkZlEyU0YkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCB2YWxpZGF0aW9uID0gKDAsICRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZVxuICAgIH0pO1xuICAgIGxldCBzZXRTZWxlY3RlZFZhbHVlID0gKHZhbHVlKT0+e1xuICAgICAgICBpZiAoIXByb3BzLmlzUmVhZE9ubHkgJiYgIXByb3BzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb24uY29tbWl0VmFsaWRhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgaXNJbnZhbGlkID0gdmFsaWRhdGlvbi5kaXNwbGF5VmFsaWRhdGlvbi5pc0ludmFsaWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsaWRhdGlvbixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZTogc2V0U2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgbGFzdEZvY3VzZWRWYWx1ZTogbGFzdEZvY3VzZWRWYWx1ZSxcbiAgICAgICAgc2V0TGFzdEZvY3VzZWRWYWx1ZTogc2V0TGFzdEZvY3VzZWRWYWx1ZSxcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZSxcbiAgICAgICAgaXNSZWFkT25seTogcHJvcHMuaXNSZWFkT25seSB8fCBmYWxzZSxcbiAgICAgICAgaXNSZXF1aXJlZDogcHJvcHMuaXNSZXF1aXJlZCB8fCBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlOiBwcm9wcy52YWxpZGF0aW9uU3RhdGUgfHwgKGlzSW52YWxpZCA/IFwiaW52YWxpZFwiIDogbnVsbCksXG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYiBhcyB1c2VSYWRpb0dyb3VwU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\n\n\n\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) // ¯\\_(ツ)_/¯\n        return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4Qjs7QUFFbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdVBBQXVQO0FBQ2pRO0FBQ0E7QUFDQSwyQkFBMkIseUNBQWE7QUFDeEMsNkJBQTZCLDJDQUFlO0FBQzVDLDRCQUE0Qix5Q0FBYTtBQUN6QyxvQ0FBb0MseUNBQWE7QUFDakQsZ0NBQWdDLDJDQUFlO0FBQy9DLCtCQUErQiwwQ0FBYztBQUM3QztBQUNBO0FBQ0Esa0NBQWtDLDBDQUFjO0FBQ2hEO0FBQ0E7QUFDQSw4Q0FBOEMsb0VBQXlCO0FBQ3ZFLCtCQUErQiwwQ0FBYztBQUM3QztBQUNBO0FBQ0Esd0RBQXdELDJDQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUFhO0FBQ2pELFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdFQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3RUFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdFQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxvRUFBbUIsTUFBTSxxRUFBb0I7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUsrSTtBQUMvSSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb24vZGlzdC9pbXBvcnQubWpzP2M5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkUXN0bzIkdXNlUmVmLCB1c2VTdGF0ZSBhcyAkUXN0bzIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJFFzdG8yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkUXN0bzIkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y29tcGFyZU5vZGVPcmRlciBhcyAkUXN0bzIkY29tcGFyZU5vZGVPcmRlciwgZ2V0Rmlyc3RJdGVtIGFzICRRc3RvMiRnZXRGaXJzdEl0ZW0sIGdldENoaWxkTm9kZXMgYXMgJFFzdG8yJGdldENoaWxkTm9kZXN9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZiBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3Ioa2V5cywgYW5jaG9yS2V5LCBjdXJyZW50S2V5KXtcbiAgICAgICAgc3VwZXIoa2V5cyk7XG4gICAgICAgIGlmIChrZXlzIGluc3RhbmNlb2YgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yS2V5ID0gYW5jaG9yS2V5IHx8IGtleXMuYW5jaG9yS2V5O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5ID0gY3VycmVudEtleSB8fCBrZXlzLmN1cnJlbnRLZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcktleSA9IGFuY2hvcktleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoc2V0QSwgc2V0Qikge1xuICAgIGlmIChzZXRBLnNpemUgIT09IHNldEIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGl0ZW0gb2Ygc2V0QSl7XG4gICAgICAgIGlmICghc2V0Qi5oYXMoaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSRleHBvcnQkMjUzZmU3OGQ0NjMyOTQ3Mihwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiwgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzLCBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3JQcm9wID0gXCJ0b2dnbGVcIiwgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvciA9IFwiYWxsXCIgfSA9IHByb3BzO1xuICAgIC8vIFdlIHdhbnQgc3luY2hyb25vdXMgdXBkYXRlcyB0byBgaXNGb2N1c2VkYCBhbmQgYGZvY3VzZWRLZXlgIGFmdGVyIHRoZWlyIHNldHRlcnMgYXJlIGNhbGxlZC5cbiAgICAvLyBCdXQgd2UgYWxzbyBuZWVkIHRvIHRyaWdnZXIgYSByZWFjdCByZS1yZW5kZXIuIFNvLCB3ZSBoYXZlIGJvdGggYSByZWYgKHN5bmMpIGFuZCBzdGF0ZSAoYXN5bmMpLlxuICAgIGxldCBpc0ZvY3VzZWRSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkXSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgZm9jdXNlZEtleVJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkS2V5XSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBzZWxlY3RlZEtleXNQcm9wID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+JDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24ocHJvcHMuc2VsZWN0ZWRLZXlzKSwgW1xuICAgICAgICBwcm9wcy5zZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgZGVmYXVsdFNlbGVjdGVkS2V5cyA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXMsIG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCkpLCBbXG4gICAgICAgIHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGVkS2V5cywgc2V0U2VsZWN0ZWRLZXlzXSA9ICgwLCAkUXN0bzIkdXNlQ29udHJvbGxlZFN0YXRlKShzZWxlY3RlZEtleXNQcm9wLCBkZWZhdWx0U2VsZWN0ZWRLZXlzLCBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgbGV0IGRpc2FibGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IFtzZWxlY3Rpb25CZWhhdmlvciwgc2V0U2VsZWN0aW9uQmVoYXZpb3JdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBpcyBzZXQgdG8gcmVwbGFjZSwgYnV0IHRoZSBjdXJyZW50IHN0YXRlIGlzIHRvZ2dsZSAoZS5nLiBkdWUgdG8gbG9uZyBwcmVzc1xuICAgIC8vIHRvIGVudGVyIHNlbGVjdGlvbiBtb2RlIG9uIHRvdWNoKSwgYW5kIHRoZSBzZWxlY3Rpb24gYmVjb21lcyBlbXB0eSwgcmVzZXQgdGhlIHNlbGVjdGlvbiBiZWhhdmlvci5cbiAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wID09PSBcInJlcGxhY2VcIiAmJiBzZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiAmJiB0eXBlb2Ygc2VsZWN0ZWRLZXlzID09PSBcIm9iamVjdFwiICYmIHNlbGVjdGVkS2V5cy5zaXplID09PSAwKSBzZXRTZWxlY3Rpb25CZWhhdmlvcihcInJlcGxhY2VcIik7XG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbkJlaGF2aW9yIHByb3AgY2hhbmdlcywgdXBkYXRlIHRoZSBzdGF0ZSBhcyB3ZWxsLlxuICAgIGxldCBsYXN0U2VsZWN0aW9uQmVoYXZpb3IgPSAoMCwgJFFzdG8yJHVzZVJlZikoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAoMCwgJFFzdG8yJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCAhPT0gbGFzdFNlbGVjdGlvbkJlaGF2aW9yLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCA9IHNlbGVjdGlvbkJlaGF2aW9yUHJvcDtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3JQcm9wXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3I6IHNlbGVjdGlvbkJlaGF2aW9yLFxuICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcjogc2V0U2VsZWN0aW9uQmVoYXZpb3IsXG4gICAgICAgIGdldCBpc0ZvY3VzZWQgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRm9jdXNlZFJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRGb2N1c2VkIChmKSB7XG4gICAgICAgICAgICBpc0ZvY3VzZWRSZWYuY3VycmVudCA9IGY7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKGYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZm9jdXNlZEtleSAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZEtleVJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRGb2N1c1N0cmF0ZWd5ICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Rm9jdXNlZEtleSAoaywgY2hpbGRGb2N1c1N0cmF0ZWd5ID0gXCJmaXJzdFwiKSB7XG4gICAgICAgICAgICBmb2N1c2VkS2V5UmVmLmN1cnJlbnQgPSBrO1xuICAgICAgICAgICAgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmLmN1cnJlbnQgPSBjaGlsZEZvY3VzU3RyYXRlZ3k7XG4gICAgICAgICAgICBzZXRGb2N1c2VkS2V5KGspO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXlzIChrZXlzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMgfHwgISQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoa2V5cywgc2VsZWN0ZWRLZXlzKSkgc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5c1Byb3AsXG4gICAgICAgIGRpc2FibGVkQmVoYXZpb3I6IGRpc2FibGVkQmVoYXZpb3JcbiAgICB9O1xufVxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4gc2VsZWN0aW9uID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHNlbGVjdGlvbik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiB7XG4gICAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHNlbGVjdGlvbiB0aGF0IGlzIGFsbG93ZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gYWxsb3dzIGVtcHR5IHNlbGVjdGlvbi5cbiAgICovIGdldCBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uQmVoYXZpb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGlvbkJlaGF2aW9yO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICovIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBjdXJyZW50bHkgZm9jdXNlZC5cbiAgICovIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBmb2N1c2VkLlxuICAgKi8gc2V0Rm9jdXNlZChpc0ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkKGlzRm9jdXNlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgY3VycmVudCBmb2N1c2VkIGtleSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBmb2N1c2VkS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5O1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBjaGlsZCBvZiB0aGUgZm9jdXNlZCBrZXkgc2hvdWxkIHJlY2VpdmUgZm9jdXMuICovIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkRm9jdXNTdHJhdGVneTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIGZvY3VzZWQga2V5LlxuICAgKi8gc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkRm9jdXNTdHJhdGVneSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQga2V5cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IG5ldyBTZXQodGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgcmF3IHNlbGVjdGlvbiB2YWx1ZSBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEVpdGhlciAnYWxsJyBmb3Igc2VsZWN0IGFsbCwgb3IgYSBzZXQgb2Yga2V5cy5cbiAgICovIGdldCByYXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIGlzU2VsZWN0ZWQoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4gICAqLyBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzICE9PSBcImFsbFwiICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBhcmUgc2VsZWN0ZWQuXG4gICAqLyBnZXQgaXNTZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0QWxsICE9IG51bGwpIHJldHVybiB0aGlzLl9pc1NlbGVjdEFsbDtcbiAgICAgICAgbGV0IGFsbEtleXMgPSB0aGlzLmdldFNlbGVjdEFsbEtleXMoKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IGFsbEtleXMuZXZlcnkoKGspPT5zZWxlY3RlZEtleXMuaGFzKGspKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0QWxsO1xuICAgIH1cbiAgICBnZXQgZmlyc3RTZWxlY3RlZEtleSgpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgZmlyc3QpIDwgMCkgZmlyc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3Qua2V5O1xuICAgIH1cbiAgICBnZXQgbGFzdFNlbGVjdGVkS2V5KCkge1xuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgbGFzdCkgPiAwKSBsYXN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRCZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvcjtcbiAgICB9XG4gICAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gZXh0ZW5kU2VsZWN0aW9uKHRvS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbih0b0tleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9LZXkgPSB0aGlzLmdldEtleSh0b0tleSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb247XG4gICAgICAgIC8vIE9ubHkgc2VsZWN0IHRoZSBvbmUga2V5IGlmIGNvbWluZyBmcm9tIGEgc2VsZWN0IGFsbC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICB0b0tleVxuICAgICAgICBdLCB0b0tleSwgdG9LZXkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgICAgIGxldCBhbmNob3JLZXkgPSBzZWxlY3RlZEtleXMuYW5jaG9yS2V5IHx8IHRvS2V5O1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0ZWRLZXlzLCBhbmNob3JLZXksIHRvS2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKGFuY2hvcktleSwgc2VsZWN0ZWRLZXlzLmN1cnJlbnRLZXkgfHwgdG9LZXkpKXNlbGVjdGlvbi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKHRvS2V5LCBhbmNob3JLZXkpKWlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldEtleVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBmcm9tSXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGZyb20pO1xuICAgICAgICBsZXQgdG9JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0odG8pO1xuICAgICAgICBpZiAoZnJvbUl0ZW0gJiYgdG9JdGVtKSB7XG4gICAgICAgICAgICBpZiAoKDAsICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyKSh0aGlzLmNvbGxlY3Rpb24sIGZyb21JdGVtLCB0b0l0ZW0pIDw9IDApIHJldHVybiB0aGlzLmdldEtleVJhbmdlSW50ZXJuYWwoZnJvbSwgdG8pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbCh0bywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRLZXlSYW5nZUludGVybmFsKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBrZXkgPSBmcm9tO1xuICAgICAgICB3aGlsZShrZXkpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS50eXBlID09PSBcIml0ZW1cIiB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0bykgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldEtleShrZXkpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIC8vIMKvXFxfKOODhClfL8KvXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIC8vIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIGp1c3QgcmV0dXJuIHRoZSBrZXkuXG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgcmV0dXJuIGtleTtcbiAgICAgICAgLy8gRmluZCBhIHBhcmVudCBpdGVtIHRvIHNlbGVjdFxuICAgICAgICB3aGlsZShpdGVtLnR5cGUgIT09IFwiaXRlbVwiICYmIGl0ZW0ucGFyZW50S2V5ICE9IG51bGwpaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGl0ZW0ucGFyZW50S2V5KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gaXRlbS5rZXk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIHRvZ2dsZVNlbGVjdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhdGhpcy5pc1NlbGVjdGVkKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQga2V5cyA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gdGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkge1xuICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGtleXMuYW5jaG9yS2V5ID0ga2V5O1xuICAgICAgICAgICAga2V5cy5jdXJyZW50S2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYga2V5cy5zaXplID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIGdpdmVuIGtleS5cbiAgICovIHJlcGxhY2VTZWxlY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgPyBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgXSwga2V5LCBrZXkpIDogbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICovIHNldFNlbGVjdGVkS2V5cyhrZXlzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cyl7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldFNlbGVjdEFsbEtleXMoKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBhZGRLZXlzID0gKGtleSk9PntcbiAgICAgICAgICAgIHdoaWxlKGtleSl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIpIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2hpbGQga2V5cy4gSWYgY2VsbCBzZWxlY3Rpb24gaXMgYWxsb3dlZCwgdGhlbiBpbmNsdWRlIGl0ZW0gY2hpbGRyZW4gdG9vLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNDaGlsZE5vZGVzICYmICh0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikpIGFkZEtleXMoKDAsICRRc3RvMiRnZXRGaXJzdEl0ZW0pKCgwLCAkUXN0bzIkZ2V0Q2hpbGROb2RlcykoaXRlbSwgdGhpcy5jb2xsZWN0aW9uKSkua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5jb2xsZWN0aW9uLmdldEtleUFmdGVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZEtleXModGhpcy5jb2xsZWN0aW9uLmdldEZpcnN0S2V5KCkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFNlbGVjdHMgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gc2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RBbGwgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm11bHRpcGxlXCIpIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKFwiYWxsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5cyBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gICAqLyBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPiAwKSkgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMobmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIGJldHdlZW4gc2VsZWN0IGFsbCBhbmQgYW4gZW1wdHkgc2VsZWN0aW9uLlxuICAgKi8gdG9nZ2xlU2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbCkgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBlbHNlIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgfVxuICAgIHNlbGVjdChrZXksIGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChrZXkpICYmICF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24pIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uQmVoYXZpb3IgPT09IFwidG9nZ2xlXCIgfHwgZSAmJiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwidmlydHVhbFwiKSkgLy8gaWYgdG91Y2ggb3IgdmlydHVhbCAoVk8pIHRoZW4gd2UganVzdCB3YW50IHRvIHRvZ2dsZSwgb3RoZXJ3aXNlIGl0J3MgaW1wb3NzaWJsZSB0byBtdWx0aSBzZWxlY3QgYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgbW9kaWZpZXIga2V5c1xuICAgICAgICB0aGlzLnRvZ2dsZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc2VsZWN0aW9uLlxuICAgKi8gaXNTZWxlY3Rpb25FcXVhbChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2V0IG9mIGtleXMgbWF0Y2guXG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnNlbGVjdGVkS2V5cztcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5zaXplICE9PSBzZWxlY3RlZEtleXMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0aW9uKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5TZWxlY3RJdGVtKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIiB8fCB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmICF0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSAmJiB0aGlzLnN0YXRlLmRpc2FibGVkQmVoYXZpb3IgPT09IFwiYWxsXCI7XG4gICAgfVxuICAgIGlzTGluayhrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcywgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICByZXR1cm4gISEoKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSkpID09PSBudWxsIHx8IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyA9IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbS5wcm9wcykgPT09IG51bGwgfHwgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHN0YXRlLCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uID0gKF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IG51bGw7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyIGFzIHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsICRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIGFzIFNlbGVjdGlvbk1hbmFnZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/slider/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/slider/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSliderState: () => (/* binding */ $28f99e3e86e6ec45$export$e5fda3247f5d67f9)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n    const { isDisabled: isDisabled = false, minValue: minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE, maxValue: maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE, numberFormatter: formatter, step: step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE, orientation: orientation = \"horizontal\" } = props;\n    // Page step should be at least equal to step and always a multiple of the step.\n    let pageSize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let calcPageSize = (maxValue - minValue) / 10;\n        calcPageSize = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n        return Math.max(calcPageSize, step);\n    }, [\n        step,\n        maxValue,\n        minValue\n    ]);\n    let restrictValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((values)=>values === null || values === void 0 ? void 0 : values.map((val, idx)=>{\n            let min = idx === 0 ? minValue : val[idx - 1];\n            let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(val, min, max, step);\n        }), [\n        minValue,\n        maxValue,\n        step\n    ]);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [\n        props.value\n    ]);\n    let defaultValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _convertValue;\n        return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [\n            minValue\n        ]);\n    }, [\n        props.defaultValue,\n        minValue\n    ]);\n    let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n    let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n    const [values, setValuesState] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(value, defaultValue, onChange);\n    const [isDraggings, setDraggingsState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Array(values.length).fill(false));\n    const isEditablesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(values.length).fill(true));\n    const [focusedIndex, setFocusedIndex] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const valuesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(values);\n    const isDraggingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isDraggings);\n    let setValues = (values)=>{\n        valuesRef.current = values;\n        setValuesState(values);\n    };\n    let setDraggings = (draggings)=>{\n        isDraggingsRef.current = draggings;\n        setDraggingsState(draggings);\n    };\n    function getValuePercent(value) {\n        return (value - minValue) / (maxValue - minValue);\n    }\n    function getThumbMinValue(index) {\n        return index === 0 ? minValue : values[index - 1];\n    }\n    function getThumbMaxValue(index) {\n        return index === values.length - 1 ? maxValue : values[index + 1];\n    }\n    function isThumbEditable(index) {\n        return isEditablesRef.current[index];\n    }\n    function setThumbEditable(index, editable) {\n        isEditablesRef.current[index] = editable;\n    }\n    function updateValue(index, value) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const thisMin = getThumbMinValue(index);\n        const thisMax = getThumbMaxValue(index);\n        // Round value to multiple of step, clamp value between min and max\n        value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, thisMin, thisMax, step);\n        let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n        setValues(newValues);\n    }\n    function updateDragging(index, dragging) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        if (dragging) valuesRef.current = values;\n        const wasDragging = isDraggingsRef.current[index];\n        isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n        setDraggings(isDraggingsRef.current);\n        // Call onChangeEnd if no handles are dragging.\n        if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n    }\n    function getFormattedValue(value) {\n        return formatter.format(value);\n    }\n    function setThumbPercent(index, percent) {\n        updateValue(index, getPercentValue(percent));\n    }\n    function getRoundedValue(value) {\n        return Math.round((value - minValue) / step) * step + minValue;\n    }\n    function getPercentValue(percent) {\n        const val = percent * (maxValue - minValue) + minValue;\n        return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(getRoundedValue(val), minValue, maxValue);\n    }\n    function incrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] + s, minValue, maxValue, step));\n    }\n    function decrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] - s, minValue, maxValue, step));\n    }\n    return {\n        values: values,\n        getThumbValue: (index)=>values[index],\n        setThumbValue: updateValue,\n        setThumbPercent: setThumbPercent,\n        isThumbDragging: (index)=>isDraggings[index],\n        setThumbDragging: updateDragging,\n        focusedThumb: focusedIndex,\n        setFocusedThumb: setFocusedIndex,\n        getThumbPercent: (index)=>getValuePercent(values[index]),\n        getValuePercent: getValuePercent,\n        getThumbValueLabel: (index)=>getFormattedValue(values[index]),\n        getFormattedValue: getFormattedValue,\n        getThumbMinValue: getThumbMinValue,\n        getThumbMaxValue: getThumbMaxValue,\n        getPercentValue: getPercentValue,\n        isThumbEditable: isThumbEditable,\n        setThumbEditable: setThumbEditable,\n        incrementThumb: incrementThumb,\n        decrementThumb: decrementThumb,\n        step: step,\n        pageSize: pageSize,\n        orientation: orientation,\n        isDisabled: isDisabled\n    };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n    if (array[index] === value) return array;\n    return [\n        ...array.slice(0, index),\n        value,\n        ...array.slice(index + 1)\n    ];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n    if (value == null) return undefined;\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n    return (newValue)=>{\n        if (typeof value === \"number\" || typeof defaultValue === \"number\") onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);\n        else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUo7QUFDZDs7QUFFekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5UkFBeVI7QUFDclM7QUFDQSx1QkFBdUIsMENBQWM7QUFDckM7QUFDQSwyQkFBMkIsaUVBQXNCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhDQUFrQjtBQUMvQztBQUNBO0FBQ0EsdUJBQXVCLGlFQUFzQjtBQUM3QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQWM7QUFDbEM7QUFDQTtBQUNBLDJCQUEyQiwwQ0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9FQUF5QjtBQUNsRSxpREFBaUQsMkNBQWU7QUFDaEUsK0JBQStCLHlDQUFhO0FBQzVDLGdEQUFnRCwyQ0FBZTtBQUMvRCwwQkFBMEIseUNBQWE7QUFDdkMsK0JBQStCLHlDQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlFQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtxRTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zbGlkZXIvZGlzdC9pbXBvcnQubWpzPzUxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzbmFwVmFsdWVUb1N0ZXAgYXMgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCwgdXNlQ29udHJvbGxlZFN0YXRlIGFzICRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUsIGNsYW1wIGFzICRhVHd1eCRjbGFtcH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGFUd3V4JHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICRhVHd1eCR1c2VDYWxsYmFjaywgdXNlU3RhdGUgYXMgJGFUd3V4JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGFUd3V4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSA9IDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9NQVhfVkFMVUUgPSAxMDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9TVEVQX1ZBTFVFID0gMTtcbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5KHByb3BzKSB7XG4gICAgY29uc3QgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkID0gZmFsc2UsIG1pblZhbHVlOiBtaW5WYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSwgbWF4VmFsdWU6IG1heFZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUFYX1ZBTFVFLCBudW1iZXJGb3JtYXR0ZXI6IGZvcm1hdHRlciwgc3RlcDogc3RlcCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiIH0gPSBwcm9wcztcbiAgICAvLyBQYWdlIHN0ZXAgc2hvdWxkIGJlIGF0IGxlYXN0IGVxdWFsIHRvIHN0ZXAgYW5kIGFsd2F5cyBhIG11bHRpcGxlIG9mIHRoZSBzdGVwLlxuICAgIGxldCBwYWdlU2l6ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IGNhbGNQYWdlU2l6ZSA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIDEwO1xuICAgICAgICBjYWxjUGFnZVNpemUgPSAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkoY2FsY1BhZ2VTaXplLCAwLCBjYWxjUGFnZVNpemUgKyBzdGVwLCBzdGVwKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNhbGNQYWdlU2l6ZSwgc3RlcCk7XG4gICAgfSwgW1xuICAgICAgICBzdGVwLFxuICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgbWluVmFsdWVcbiAgICBdKTtcbiAgICBsZXQgcmVzdHJpY3RWYWx1ZXMgPSAoMCwgJGFUd3V4JHVzZUNhbGxiYWNrKSgodmFsdWVzKT0+dmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLm1hcCgodmFsLCBpZHgpPT57XG4gICAgICAgICAgICBsZXQgbWluID0gaWR4ID09PSAwID8gbWluVmFsdWUgOiB2YWxbaWR4IC0gMV07XG4gICAgICAgICAgICBsZXQgbWF4ID0gaWR4ID09PSB2YWx1ZXMubGVuZ3RoIC0gMSA/IG1heFZhbHVlIDogdmFsW2lkeCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWwsIG1pbiwgbWF4LCBzdGVwKTtcbiAgICAgICAgfSksIFtcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBzdGVwXG4gICAgXSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+cmVzdHJpY3RWYWx1ZXMoJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZShwcm9wcy52YWx1ZSkpLCBbXG4gICAgICAgIHByb3BzLnZhbHVlXG4gICAgXSk7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgdmFyIF9jb252ZXJ0VmFsdWU7XG4gICAgICAgIHJldHVybiByZXN0cmljdFZhbHVlcygoX2NvbnZlcnRWYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjb252ZXJ0VmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSkgIT09IG51bGwgJiYgX2NvbnZlcnRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbnZlcnRWYWx1ZSA6IFtcbiAgICAgICAgICAgIG1pblZhbHVlXG4gICAgICAgIF0pO1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZVxuICAgIF0pO1xuICAgIGxldCBvbkNoYW5nZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IG9uQ2hhbmdlRW5kID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlRW5kKTtcbiAgICBjb25zdCBbdmFsdWVzLCBzZXRWYWx1ZXNTdGF0ZV0gPSAoMCwgJGFUd3V4JHVzZUNvbnRyb2xsZWRTdGF0ZSkodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5ncywgc2V0RHJhZ2dpbmdzU3RhdGVdID0gKDAsICRhVHd1eCR1c2VTdGF0ZSkobmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpLmZpbGwoZmFsc2UpKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlc1JlZiA9ICgwLCAkYVR3dXgkdXNlUmVmKShuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCkuZmlsbCh0cnVlKSk7XG4gICAgY29uc3QgW2ZvY3VzZWRJbmRleCwgc2V0Rm9jdXNlZEluZGV4XSA9ICgwLCAkYVR3dXgkdXNlU3RhdGUpKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdmFsdWVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKHZhbHVlcyk7XG4gICAgY29uc3QgaXNEcmFnZ2luZ3NSZWYgPSAoMCwgJGFUd3V4JHVzZVJlZikoaXNEcmFnZ2luZ3MpO1xuICAgIGxldCBzZXRWYWx1ZXMgPSAodmFsdWVzKT0+e1xuICAgICAgICB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcbiAgICAgICAgc2V0VmFsdWVzU3RhdGUodmFsdWVzKTtcbiAgICB9O1xuICAgIGxldCBzZXREcmFnZ2luZ3MgPSAoZHJhZ2dpbmdzKT0+e1xuICAgICAgICBpc0RyYWdnaW5nc1JlZi5jdXJyZW50ID0gZHJhZ2dpbmdzO1xuICAgICAgICBzZXREcmFnZ2luZ3NTdGF0ZShkcmFnZ2luZ3MpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVQZXJjZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRodW1iTWluVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gbWluVmFsdWUgOiB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGh1bWJNYXhWYWx1ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IHZhbHVlcy5sZW5ndGggLSAxID8gbWF4VmFsdWUgOiB2YWx1ZXNbaW5kZXggKyAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaHVtYkVkaXRhYmxlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGh1bWJFZGl0YWJsZShpbmRleCwgZWRpdGFibGUpIHtcbiAgICAgICAgaXNFZGl0YWJsZXNSZWYuY3VycmVudFtpbmRleF0gPSBlZGl0YWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8ICFpc1RodW1iRWRpdGFibGUoaW5kZXgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRoaXNNaW4gPSBnZXRUaHVtYk1pblZhbHVlKGluZGV4KTtcbiAgICAgICAgY29uc3QgdGhpc01heCA9IGdldFRodW1iTWF4VmFsdWUoaW5kZXgpO1xuICAgICAgICAvLyBSb3VuZCB2YWx1ZSB0byBtdWx0aXBsZSBvZiBzdGVwLCBjbGFtcCB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICAgIHZhbHVlID0gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbHVlLCB0aGlzTWluLCB0aGlzTWF4LCBzdGVwKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlcyA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgodmFsdWVzUmVmLmN1cnJlbnQsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHNldFZhbHVlcyhuZXdWYWx1ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEcmFnZ2luZyhpbmRleCwgZHJhZ2dpbmcpIHtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgIWlzVGh1bWJFZGl0YWJsZShpbmRleCkpIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcbiAgICAgICAgY29uc3Qgd2FzRHJhZ2dpbmcgPSBpc0RyYWdnaW5nc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICAgICAgaXNEcmFnZ2luZ3NSZWYuY3VycmVudCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoaXNEcmFnZ2luZ3NSZWYuY3VycmVudCwgaW5kZXgsIGRyYWdnaW5nKTtcbiAgICAgICAgc2V0RHJhZ2dpbmdzKGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQpO1xuICAgICAgICAvLyBDYWxsIG9uQ2hhbmdlRW5kIGlmIG5vIGhhbmRsZXMgYXJlIGRyYWdnaW5nLlxuICAgICAgICBpZiAob25DaGFuZ2VFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQuc29tZShCb29sZWFuKSkgb25DaGFuZ2VFbmQodmFsdWVzUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRodW1iUGVyY2VudChpbmRleCwgcGVyY2VudCkge1xuICAgICAgICB1cGRhdGVWYWx1ZShpbmRleCwgZ2V0UGVyY2VudFZhbHVlKHBlcmNlbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um91bmRlZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSAtIG1pblZhbHVlKSAvIHN0ZXApICogc3RlcCArIG1pblZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkge1xuICAgICAgICBjb25zdCB2YWwgPSBwZXJjZW50ICogKG1heFZhbHVlIC0gbWluVmFsdWUpICsgbWluVmFsdWU7XG4gICAgICAgIHJldHVybiAoMCwgJGFUd3V4JGNsYW1wKShnZXRSb3VuZGVkVmFsdWUodmFsKSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50VGh1bWIoaW5kZXgsIHN0ZXBTaXplID0gMSkge1xuICAgICAgICBsZXQgcyA9IE1hdGgubWF4KHN0ZXBTaXplLCBzdGVwKTtcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdICsgcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY3JlbWVudFRodW1iKGluZGV4LCBzdGVwU2l6ZSA9IDEpIHtcbiAgICAgICAgbGV0IHMgPSBNYXRoLm1heChzdGVwU2l6ZSwgc3RlcCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlKGluZGV4LCAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkodmFsdWVzW2luZGV4XSAtIHMsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgZ2V0VGh1bWJWYWx1ZTogKGluZGV4KT0+dmFsdWVzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJWYWx1ZTogdXBkYXRlVmFsdWUsXG4gICAgICAgIHNldFRodW1iUGVyY2VudDogc2V0VGh1bWJQZXJjZW50LFxuICAgICAgICBpc1RodW1iRHJhZ2dpbmc6IChpbmRleCk9PmlzRHJhZ2dpbmdzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJEcmFnZ2luZzogdXBkYXRlRHJhZ2dpbmcsXG4gICAgICAgIGZvY3VzZWRUaHVtYjogZm9jdXNlZEluZGV4LFxuICAgICAgICBzZXRGb2N1c2VkVGh1bWI6IHNldEZvY3VzZWRJbmRleCxcbiAgICAgICAgZ2V0VGh1bWJQZXJjZW50OiAoaW5kZXgpPT5nZXRWYWx1ZVBlcmNlbnQodmFsdWVzW2luZGV4XSksXG4gICAgICAgIGdldFZhbHVlUGVyY2VudDogZ2V0VmFsdWVQZXJjZW50LFxuICAgICAgICBnZXRUaHVtYlZhbHVlTGFiZWw6IChpbmRleCk9PmdldEZvcm1hdHRlZFZhbHVlKHZhbHVlc1tpbmRleF0pLFxuICAgICAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZ2V0Rm9ybWF0dGVkVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWluVmFsdWU6IGdldFRodW1iTWluVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWF4VmFsdWU6IGdldFRodW1iTWF4VmFsdWUsXG4gICAgICAgIGdldFBlcmNlbnRWYWx1ZTogZ2V0UGVyY2VudFZhbHVlLFxuICAgICAgICBpc1RodW1iRWRpdGFibGU6IGlzVGh1bWJFZGl0YWJsZSxcbiAgICAgICAgc2V0VGh1bWJFZGl0YWJsZTogc2V0VGh1bWJFZGl0YWJsZSxcbiAgICAgICAgaW5jcmVtZW50VGh1bWI6IGluY3JlbWVudFRodW1iLFxuICAgICAgICBkZWNyZW1lbnRUaHVtYjogZGVjcmVtZW50VGh1bWIsXG4gICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSByZXR1cm4gYXJyYXk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoaW5kZXggKyAxKVxuICAgIF07XG59XG5mdW5jdGlvbiAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXG4gICAgICAgIHZhbHVlXG4gICAgXTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIHJldHVybiAobmV3VmFsdWUpPT57XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJudW1iZXJcIikgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG5ld1ZhbHVlWzBdKTtcbiAgICAgICAgZWxzZSBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UobmV3VmFsdWUpO1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI4Zjk5ZTNlODZlNmVjNDUkZXhwb3J0JGU1ZmRhMzI0N2Y1ZDY3ZjkgYXMgdXNlU2xpZGVyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/slider/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex items’ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the item’s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the item’s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen item’s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the item’s\n     * target main size was made smaller by this, it’s a max\n     * violation. If the item’s target main size was made\n     * larger by this, it’s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * ∑(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\n\n\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\n\n\n\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)// eslint-disable-next-line max-depth\n                if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns.find((column)=>{\n            var _column_props, _column_props1;\n            return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);\n        }).key);\n    }\n}\n\n\n\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n                // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n\n\n\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n            child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else // We enforce that the cells come before rows so can just reuse cell index\n            visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBcUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSxVQUFVLHVHQUF1RztBQUNqSCxrREFBa0QsMkNBQWU7QUFDakUsMkJBQTJCLDBDQUFjO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBDQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJDQUFlO0FBQ3pFO0FBQ0EsNENBQTRDLDJDQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBa0I7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsMENBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNERBQTRELCtEQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1FQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDJDQUFlO0FBQzNGLFVBQVUsNEhBQTRIO0FBQ3RJLHNCQUFzQiwwQ0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFFQUFvQixhQUFhLDhDQUFrQjtBQUM1RTtBQUNBO0FBQ0EsVUFBVSxpRUFBaUUsTUFBTSw2REFBbUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsWUFBWSxrQ0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLG9CQUFvQixrQ0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUErRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxRkFBcUY7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixrQ0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQiwwSEFBMEgsY0FBYyxZQUFZLHdCQUF3QjtBQUM1SztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQSxVQUFVLHNTQUFzUztBQUNoVCxhQUFhLGlFQUFzQjtBQUNuQyw4Q0FBOEMsb0VBQXlCO0FBQ3ZFLHNCQUFzQiwwQ0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUFjLGNBQWMseUVBQXdCO0FBQzFFLG9CQUFvQiwwQ0FBYztBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQ0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBYztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNHNCO0FBQzVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJsZS9kaXN0L2ltcG9ydC5tanM/NmY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NlY3Rpb24gYXMgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24sIHVzZUNvbGxlY3Rpb24gYXMgJDFCZmpXJHVzZUNvbGxlY3Rpb24sIGdldEZpcnN0SXRlbSBhcyAkMUJmalckZ2V0Rmlyc3RJdGVtLCBnZXRMYXN0SXRlbSBhcyAkMUJmalckZ2V0TGFzdEl0ZW0sIENvbGxlY3Rpb25CdWlsZGVyIGFzICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQgJDFCZmpXJHJlYWN0LCB7dXNlU3RhdGUgYXMgJDFCZmpXJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQxQmZqVyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkMUJmalckdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VHcmlkU3RhdGUgYXMgJDFCZmpXJHVzZUdyaWRTdGF0ZSwgR3JpZENvbGxlY3Rpb24gYXMgJDFCZmpXJEdyaWRDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZ3JpZFwiO1xuaW1wb3J0IHt0YWJsZU5lc3RlZFJvd3MgYXMgJDFCZmpXJHRhYmxlTmVzdGVkUm93c30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2ZsYWdzXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KHdpZHRoKSB7XG4gICAgcmV0dXJuIHdpZHRoICE9IG51bGwgJiYgKCFpc05hTih3aWR0aCkgfHwgU3RyaW5nKHdpZHRoKS5tYXRjaCgvXihcXGQrKSg/PSUkKS8pICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKSB7XG4gICAgaWYgKCF3aWR0aCkgcmV0dXJuIDE7XG4gICAgbGV0IG1hdGNoID0gd2lkdGgubWF0Y2goL14oLispKD89ZnIkKS8pO1xuICAgIC8vIGlmIHdpZHRoIGlzIHRoZSBpbmNvcnJlY3QgZm9ybWF0LCBqdXN0IGRlZmF1bHQgaXQgdG8gYSAxZnJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgd2lkdGg6ICR7d2lkdGh9IGlzIG5vdCBhIHN1cHBvcnRlZCBmb3JtYXQsIHdpZHRoIHNob3VsZCBiZSBhIG51bWJlciAoZXguIDE1MCksIHBlcmNlbnRhZ2UgKGV4LiAnNTAlJykgb3IgZnIgdW5pdCAoZXguICcyZnInKWAsIFwiZGVmYXVsdGluZyB0byAnMWZyJ1wiKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzBdKTtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCB0YWJsZVdpZHRoKSB7XG4gICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXihcXGQrKSg/PSUkKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHBlcmNlbnRhZ2VzIG9yIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBmb3Igc3RhdGljIGNvbHVtbiB3aWR0aHNcIik7XG4gICAgICAgIHJldHVybiB0YWJsZVdpZHRoICogKHBhcnNlRmxvYXQobWF0Y2hbMF0pIC8gMTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTAobWF4V2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICByZXR1cm4gbWF4V2lkdGggIT0gbnVsbCA/ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKG1heFdpZHRoLCB0YWJsZVdpZHRoKSA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEobWluV2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICByZXR1cm4gbWluV2lkdGggIT0gbnVsbCA/ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKG1pbldpZHRoLCB0YWJsZVdpZHRoKSA6IDA7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MShhdmFpbGFibGVXaWR0aCwgY29sdW1ucywgY2hhbmdlZENvbHVtbnMsIGdldERlZmF1bHRXaWR0aCwgZ2V0RGVmYXVsdE1pbldpZHRoKSB7XG4gICAgbGV0IGhhc05vbkZyb3plbkl0ZW1zID0gZmFsc2U7XG4gICAgbGV0IGZsZXhJdGVtcyA9IGNvbHVtbnMubWFwKChjb2x1bW4sIGluZGV4KT0+e1xuICAgICAgICB2YXIgX2NvbHVtbl93aWR0aCwgX3JlZiwgX3JlZjE7XG4gICAgICAgIGxldCB3aWR0aCA9IGNoYW5nZWRDb2x1bW5zLmdldChjb2x1bW4ua2V5KSAhPSBudWxsID8gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpIDogKF9yZWYxID0gKF9yZWYgPSAoX2NvbHVtbl93aWR0aCA9IGNvbHVtbi53aWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl93aWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl93aWR0aCA6IGNvbHVtbi5kZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBnZXREZWZhdWx0V2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0V2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMSAhPT0gdm9pZCAwID8gX3JlZjEgOiBcIjFmclwiO1xuICAgICAgICBsZXQgZnJvemVuID0gZmFsc2U7XG4gICAgICAgIGxldCBiYXNlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBmbGV4ID0gMDtcbiAgICAgICAgbGV0IHRhcmdldE1haW5TaXplID0gbnVsbDtcbiAgICAgICAgaWYgKCQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KHdpZHRoKSkge1xuICAgICAgICAgICAgYmFzZVNpemUgPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5Zih3aWR0aCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsZXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCh3aWR0aCk7XG4gICAgICAgICAgICBpZiAoZmxleCA8PSAwKSBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfY29sdW1uX21pbldpZHRoLCBfcmVmMjtcbiAgICAgICAgbGV0IG1pbiA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKChfcmVmMiA9IChfY29sdW1uX21pbldpZHRoID0gY29sdW1uLm1pbldpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX21pbldpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX21pbldpZHRoIDogZ2V0RGVmYXVsdE1pbldpZHRoID09PSBudWxsIHx8IGdldERlZmF1bHRNaW5XaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RGVmYXVsdE1pbldpZHRoKGluZGV4KSkgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogMCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBsZXQgbWF4ID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTAoY29sdW1uLm1heFdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBoeXBvdGhldGljYWxNYWluU2l6ZSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4oYmFzZVNpemUsIG1heCkpO1xuICAgICAgICAvLyA5LjcuMVxuICAgICAgICAvLyBXZSBkb24ndCBtYWtlIHVzZSBvZiBmbGV4IGJhc2lzLCBpdCdzIGFsd2F5cyAwLCBzbyB3ZSBhcmUgYWx3YXlzIGluICdncm93JyBtb2RlLlxuICAgICAgICAvLyA5LjcuMlxuICAgICAgICBpZiAoZnJvemVuKSB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICBlbHNlIGlmIChiYXNlU2l6ZSA+IGh5cG90aGV0aWNhbE1haW5TaXplKSB7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemUgPSBoeXBvdGhldGljYWxNYWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjcuM1xuICAgICAgICBpZiAoIWZyb3plbikgaGFzTm9uRnJvemVuSXRlbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvemVuOiBmcm96ZW4sXG4gICAgICAgICAgICBiYXNlU2l6ZTogYmFzZVNpemUsXG4gICAgICAgICAgICBoeXBvdGhldGljYWxNYWluU2l6ZTogaHlwb3RoZXRpY2FsTWFpblNpemUsXG4gICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgZmxleDogZmxleCxcbiAgICAgICAgICAgIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSxcbiAgICAgICAgICAgIHZpb2xhdGlvbjogMFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIDkuNy40XG4gICAgLy8gOS43LjQuYVxuICAgIHdoaWxlKGhhc05vbkZyb3plbkl0ZW1zKXtcbiAgICAgICAgLy8gOS43LjQuYlxuICAgICAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlIGFzIGZvciBpbml0aWFsIGZyZWUgc3BhY2UsXG4gICAgICogYWJvdmUgKDkuNy4zKS4gSWYgdGhlIHN1bSBvZiB0aGUgdW5mcm96ZW4gZmxleCBpdGVtc+KAmSBmbGV4IGZhY3RvcnMgaXNcbiAgICAgKiBsZXNzIHRoYW4gb25lLCBtdWx0aXBseSB0aGUgaW5pdGlhbCBmcmVlIHNwYWNlIGJ5IHRoaXMgc3VtIChvZiBmbGV4IGZhY3RvcnMpLlxuICAgICAqIElmIHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1hZ25pdHVkZSBvZlxuICAgICAqIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSwgdXNlIHRoaXMgYXMgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLlxuICAgICAqLyBsZXQgdXNlZFdpZHRoID0gMDtcbiAgICAgICAgbGV0IGZsZXhGYWN0b3JzID0gMDtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpZiAoaXRlbS5mcm96ZW4pIHVzZWRXaWR0aCArPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXNlZFdpZHRoICs9IGl0ZW0uYmFzZVNpemU7XG4gICAgICAgICAgICAgICAgZmxleEZhY3RvcnMgKz0gaXRlbS5mbGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0ZyZWVTcGFjZSA9IGF2YWlsYWJsZVdpZHRoIC0gdXNlZFdpZHRoO1xuICAgICAgICAvLyB3ZSBvbmx5IHN1cHBvcnQgaW50ZWdlciBGUidzLCBhbmQgYmVjYXVzZSBvZiBoYXNOb25Gcm96ZW5JdGVtcywgd2Uga25vdyB0aGF0IGZsZXhGYWN0b3JzID4gMFxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGNoZWNrIGZvciBmbGV4RmFjdG9ycyA8IDFcbiAgICAgICAgLy8gOS43LjQuY1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgaXMgemVyb1xuICAgICAqIC0gRG8gbm90aGluZy5cbiAgICAgKiBFbHNlIC8vIHJlbWVtYmVyLCB3ZSdyZSBhbHdheXMgaW4gZ3JvdyBtb2RlXG4gICAgICogLSBGaW5kIHRoZSByYXRpbyBvZiB0aGUgaXRlbeKAmXMgZmxleCBncm93IGZhY3RvciB0byB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGZsZXggZ3JvdyBmYWN0b3JzIG9mIGFsbCB1bmZyb3plbiBpdGVtcyBvblxuICAgICAqIHRoZSBsaW5lLiBTZXQgdGhlIGl0ZW3igJlzIHRhcmdldCBtYWluIHNpemUgdG8gaXRzIGZsZXhcbiAgICAgKiBiYXNlIHNpemUgcGx1cyBhIGZyYWN0aW9uIG9mIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZVxuICAgICAqIHByb3BvcnRpb25hbCB0byB0aGUgcmF0aW8uXG4gICAgICovIGlmIChyZW1haW5pbmdGcmVlU3BhY2UgPiAwKSBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSBpdGVtLmZsZXggLyBmbGV4RmFjdG9ycztcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gaXRlbS5iYXNlU2l6ZSArIHJhdGlvICogcmVtYWluaW5nRnJlZVNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gOS43LjQuZFxuICAgICAgICAvKipcbiAgICAgKiBGaXggbWluL21heCB2aW9sYXRpb25zLiBDbGFtcCBlYWNoIG5vbi1mcm96ZW4gaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIGJ5IGl0cyB1c2VkIG1pbiBhbmQgbWF4IG1haW4gc2l6ZXNcbiAgICAgKiBhbmQgZmxvb3IgaXRzIGNvbnRlbnQtYm94IHNpemUgYXQgemVyby4gSWYgdGhlIGl0ZW3igJlzXG4gICAgICogdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZSBzbWFsbGVyIGJ5IHRoaXMsIGl04oCZcyBhIG1heFxuICAgICAqIHZpb2xhdGlvbi4gSWYgdGhlIGl0ZW3igJlzIHRhcmdldCBtYWluIHNpemUgd2FzIG1hZGVcbiAgICAgKiBsYXJnZXIgYnkgdGhpcywgaXTigJlzIGEgbWluIHZpb2xhdGlvbi5cbiAgICAgKi8gbGV0IHRvdGFsVmlvbGF0aW9uID0gMDtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpdGVtLnZpb2xhdGlvbiA9IDA7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWluOiBtaW4sIG1heDogbWF4LCB0YXJnZXRNYWluU2l6ZTogdGFyZ2V0TWFpblNpemUgfSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRNYWluU2l6ZSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4odGFyZ2V0TWFpblNpemUsIG1heCkpO1xuICAgICAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gaXRlbS50YXJnZXRNYWluU2l6ZSAtIHRhcmdldE1haW5TaXplO1xuICAgICAgICAgICAgICAgIHRvdGFsVmlvbGF0aW9uICs9IGl0ZW0udmlvbGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gOS43LjQuZVxuICAgICAgICAvKipcbiAgICAgKiBGcmVlemUgb3Zlci1mbGV4ZWQgaXRlbXMuIFRoZSB0b3RhbCB2aW9sYXRpb24gaXMgdGhlXG4gICAgICogc3VtIG9mIHRoZSBhZGp1c3RtZW50cyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICog4oiRKGNsYW1wZWQgc2l6ZSAtIHVuY2xhbXBlZCBzaXplKS4gSWYgdGhlIHRvdGFsIHZpb2xhdGlvbiBpczpcbiAgICAgKiBaZXJvXG4gICAgICogLSBGcmVlemUgYWxsIGl0ZW1zLlxuICAgICAqXG4gICAgICogUG9zaXRpdmVcbiAgICAgKiAtIEZyZWV6ZSBhbGwgdGhlIGl0ZW1zIHdpdGggbWluIHZpb2xhdGlvbnMuXG4gICAgICpcbiAgICAgKiBOZWdhdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtYXggdmlvbGF0aW9ucy5cbiAgICAgKi8gaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpZiAodG90YWxWaW9sYXRpb24gPT09IDAgfHwgTWF0aC5zaWduKHRvdGFsVmlvbGF0aW9uKSA9PT0gTWF0aC5zaWduKGl0ZW0udmlvbGF0aW9uKSkgaXRlbS5mcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWl0ZW0uZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyhmbGV4SXRlbXMpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyhmbGV4SXRlbXMpIHtcbiAgICAvKlxuICBHaXZlbiBhbiBhcnJheSBvZiBmbG9hdHMgdGhhdCBzdW0gdG8gYW4gaW50ZWdlciwgdGhpcyByb3VuZHMgdGhlIGZsb2F0c1xuICBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIHRoZSBzYW1lIHN1bS5cbiAgKi8gbGV0IGZwVG90YWwgPSAwO1xuICAgIGxldCBpbnRUb3RhbCA9IDA7XG4gICAgbGV0IHJvdW5kZWRBcnJheSA9IFtdO1xuICAgIGZsZXhJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgbGV0IGZsb2F0ID0gaXRlbS50YXJnZXRNYWluU2l6ZTtcbiAgICAgICAgbGV0IGludGVnZXIgPSBNYXRoLnJvdW5kKGZsb2F0ICsgZnBUb3RhbCkgLSBpbnRUb3RhbDtcbiAgICAgICAgZnBUb3RhbCArPSBmbG9hdDtcbiAgICAgICAgaW50VG90YWwgKz0gaW50ZWdlcjtcbiAgICAgICAgcm91bmRlZEFycmF5LnB1c2goaW50ZWdlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdW5kZWRBcnJheTtcbn1cblxuXG5jbGFzcyAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSB7XG4gICAgLyoqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIHNwbGl0cyBpdCBpbnRvIDIgbWFwcyBvZiBjb2x1bW5zIHdpdGggY29udHJvbGxlZCBhbmQgY29sdW1ucyB3aXRoIHVuY29udHJvbGxlZCB3aWR0aHMuICovIHNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKChhY2MsIGNvbCk9PntcbiAgICAgICAgICAgIGlmIChjb2wucHJvcHMud2lkdGggIT0gbnVsbCkgYWNjWzBdLnNldChjb2wua2V5LCBjb2wpO1xuICAgICAgICAgICAgZWxzZSBhY2NbMV0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBuZXcgTWFwKCksXG4gICAgICAgICAgICBuZXcgTWFwKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKiBUYWtlcyB1bmNvbnRyb2xsZWQgYW5kIGNvbnRyb2xsZWQgd2lkdGhzIGFuZCBqb2lucyB0aGVtIGludG8gYSBzaW5nbGUgTWFwLiAqLyByZWNvbWJpbmVDb2x1bW5zKGNvbHVtbnMsIHVuY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkQ29sdW1ucywgY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoY29sdW1ucy5tYXAoKGNvbCk9PntcbiAgICAgICAgICAgIGlmICh1bmNvbnRyb2xsZWRDb2x1bW5zLmhhcyhjb2wua2V5KSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sLmtleSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBlbHNlIHJldHVybiBbXG4gICAgICAgICAgICAgICAgY29sLmtleSxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVkQ29sdW1ucy5nZXQoY29sLmtleSkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqIFVzZWQgdG8gbWFrZSBhbiBpbml0aWFsIE1hcCBvZiB0aGUgdW5jb250cm9sbGVkIHdpZHRocyBiYXNlZCBvbiBkZWZhdWx0IHdpZHRocy4gKi8gZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20odW5jb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5LCBjb2xdKT0+e1xuICAgICAgICAgICAgdmFyIF90aGlzX2dldERlZmF1bHRXaWR0aCwgX3RoaXM7XG4gICAgICAgICAgICB2YXIgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGgsIF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAoX3JlZiA9IChfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCA9IGNvbC5wcm9wcy5kZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoICE9PSB2b2lkIDAgPyBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCA6IChfdGhpc19nZXREZWZhdWx0V2lkdGggPSAoX3RoaXMgPSB0aGlzKS5nZXREZWZhdWx0V2lkdGgpID09PSBudWxsIHx8IF90aGlzX2dldERlZmF1bHRXaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RGVmYXVsdFdpZHRoLmNhbGwoX3RoaXMsIGNvbCkpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBcIjFmclwiXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldENvbHVtbldpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uV2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5XaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5XaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbldpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NaW5XaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCA9IHRoaXMuY29sdW1uTWluV2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgZ2V0Q29sdW1uTWF4V2lkdGgoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQgPSB0aGlzLmNvbHVtbk1heFdpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCA6IDA7XG4gICAgfVxuICAgIHJlc2l6ZUNvbHVtbldpZHRoKHRhYmxlV2lkdGgsIGNvbGxlY3Rpb24sIGNvbnRyb2xsZWRXaWR0aHMsIHVuY29udHJvbGxlZFdpZHRocywgY29sID0gbnVsbCwgd2lkdGgpIHtcbiAgICAgICAgbGV0IHByZXZDb2x1bW5XaWR0aHMgPSB0aGlzLmNvbHVtbldpZHRocztcbiAgICAgICAgLy8gcmVzaXppbmcgYSBjb2x1bW5cbiAgICAgICAgbGV0IHJlc2l6ZUluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCByZXNpemluZ0NoYW5nZWQgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIC4uLmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgICAgICAuLi51bmNvbnRyb2xsZWRXaWR0aHNcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBwZXJjZW50S2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGZyS2V5c1RvVGhlUmlnaHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBtaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGZyZWV6ZSBjb2x1bW5zIHRvIHRoZSBsZWZ0IHRvIHRoZWlyIHByZXZpb3VzIHBpeGVsIHZhbHVlXG4gICAgICAgIGNvbGxlY3Rpb24uY29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGkpPT57XG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCwgX2NvbHVtbl9wcm9wc193aWR0aDtcbiAgICAgICAgICAgIGxldCBmcktleTtcbiAgICAgICAgICAgIGxldCBmclZhbHVlO1xuICAgICAgICAgICAgbWluV2lkdGhzLnNldChjb2x1bW4ua2V5LCB0aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pKTtcbiAgICAgICAgICAgIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgIWNvbHVtbi5wcm9wcy53aWR0aCAmJiAhKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKSkge1xuICAgICAgICAgICAgICAgIC8vIHVuY29udHJvbGxlZCBkb24ndCBoYXZlIHByb3BzLndpZHRoIGZvciB1cywgc28gaW5zdGVhZCBnZXQgZnJvbSBvdXIgc3RhdGVcbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XG4gICAgICAgICAgICAgICAgZnJWYWx1ZSA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCkodW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KShjb2x1bW4ucHJvcHMud2lkdGgpICYmICF1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGxlZFdpZHRocyB3aWxsIGJlIHRoZSBzYW1lIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZnJLZXkgPSBjb2x1bW4ua2V5O1xuICAgICAgICAgICAgICAgIGZyVmFsdWUgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQpKGNvbHVtbi5wcm9wcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAoKF9jb2x1bW5fcHJvcHNfd2lkdGggPSBjb2x1bW4ucHJvcHMud2lkdGgpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHNfd2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID0gX2NvbHVtbl9wcm9wc193aWR0aC5lbmRzV2l0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aC5jYWxsKF9jb2x1bW5fcHJvcHNfd2lkdGgsIFwiJVwiKSkpIHBlcmNlbnRLZXlzLnNldChjb2x1bW4ua2V5LCBjb2x1bW4ucHJvcHMud2lkdGgpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgZnJlZXplIGNvbHVtbnMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByZXNpemluZyBvbmVcbiAgICAgICAgICAgIGlmIChyZXNpemVJbmRleCA8IGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJLZXkpIGZyS2V5c1RvVGhlUmlnaHQuc2V0KGZyS2V5LCBmclZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhlIG5ldyBzaXplIG9mIHRoZSByZXNpemluZyBjb2x1bW5cbiAgICAgICAgICAgIGlmIChjb2x1bW4ua2V5ID09PSBjb2wpIHtcbiAgICAgICAgICAgICAgICByZXNpemVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmVzaXppbmdDaGFuZ2VkLnNldChjb2x1bW4ua2V5LCBNYXRoLmZsb29yKHdpZHRoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZnJlZXplIGNvbHVtbiB0byBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgcmVzaXppbmdDaGFuZ2VkLnNldChjb2x1bW4ua2V5LCBwcmV2Q29sdW1uV2lkdGhzLmdldChjb2x1bW4ua2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcmVkaWN0IHBpeGVscyBzaXplcyBmb3IgYWxsIGNvbHVtbnMgYmFzZWQgb24gcmVzaXplXG4gICAgICAgIGxldCBjb2x1bW5XaWR0aHMgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU1ZDUwZGM2ODczODU0OTEpKHRhYmxlV2lkdGgsIGNvbGxlY3Rpb24uY29sdW1ucy5tYXAoKGNvbCk9Pih7XG4gICAgICAgICAgICAgICAgLi4uY29sLnByb3BzLFxuICAgICAgICAgICAgICAgIGtleTogY29sLmtleVxuICAgICAgICAgICAgfSkpLCByZXNpemluZ0NoYW5nZWQsIChpKT0+dGhpcy5nZXREZWZhdWx0V2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSwgKGkpPT50aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pKTtcbiAgICAgICAgLy8gc2V0IGFsbCBuZXcgY29sdW1uIHdpZHRocyBmb3Igb25SZXNpemUgZXZlbnRcbiAgICAgICAgLy8gY29sdW1ucyBnb2luZyBpbiB3aWxsIGJlIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zIGNvbWluZyBvdXRcbiAgICAgICAgbGV0IG5ld1dpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gc2V0IGFsbCBjb2x1bW4gd2lkdGhzIGJhc2VkIG9uIGNhbGN1bGF0ZUNvbHVtblNpemVcbiAgICAgICAgY29sdW1uV2lkdGhzLmZvckVhY2goKHdpZHRoLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCBrZXkgPSBjb2xsZWN0aW9uLmNvbHVtbnNbaW5kZXhdLmtleTtcbiAgICAgICAgICAgIG5ld1dpZHRocy5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgRlIncyBiYWNrIGFzIHRoZXkgd2VyZSB0byBjb2x1bW5zIHRvIHRoZSByaWdodFxuICAgICAgICBBcnJheS5mcm9tKGZyS2V5c1RvVGhlUmlnaHQpLmZvckVhY2goKFtrZXldKT0+e1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIGAke2ZyS2V5c1RvVGhlUmlnaHQuZ2V0KGtleSl9ZnJgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHB1dCBiYWNrIGluIHBlcmNlbnRzXG4gICAgICAgIEFycmF5LmZyb20ocGVyY2VudEtleXMpLmZvckVhY2goKFtrZXksIHdpZHRoXSk9PntcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIGxvY2tzIGEgY29sdW1uIHRvIGEgcHggd2lkdGhcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGNvbCkgcmV0dXJuO1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdXaWR0aHM7XG4gICAgfVxuICAgIGJ1aWxkQ29sdW1uV2lkdGhzKHRhYmxlV2lkdGgsIGNvbGxlY3Rpb24sIHdpZHRocykge1xuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBpbml0aWFsIGxheW91dCBvciB0YWJsZS93aW5kb3cgcmVzaXppbmdcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcbiAgICAgICAgICAgICAgICAuLi5jb2wucHJvcHMsXG4gICAgICAgICAgICAgICAga2V5OiBjb2wua2V5XG4gICAgICAgICAgICB9KSksIHdpZHRocywgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAvLyBjb2x1bW5zIGdvaW5nIGluIHdpbGwgYmUgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnMgY29taW5nIG91dFxuICAgICAgICBjb2x1bW5XaWR0aHMuZm9yRWFjaCgod2lkdGgsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRocy5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wc19taW5XaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWluV2lkdGhzLnNldChrZXksICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMSkoKF9jb2x1bW5fcHJvcHNfbWluV2lkdGggPSBjb2x1bW4ucHJvcHMubWluV2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fcHJvcHNfbWluV2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fcHJvcHNfbWluV2lkdGggOiB0aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2x1bW4pLCB0YWJsZVdpZHRoKSk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbk1heFdpZHRocy5zZXQoa2V5LCAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTApKGNvbHVtbi5wcm9wcy5tYXhXaWR0aCwgdGFibGVXaWR0aCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uV2lkdGhzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcbiAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWluV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1heFdpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIF9vcHRpb25zX2dldERlZmF1bHRXaWR0aDtcbiAgICAgICAgdGhpcy5nZXREZWZhdWx0V2lkdGggPSAoX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdldERlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoICE9PSB2b2lkIDAgPyBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggOiAoKT0+XCIxZnJcIjtcbiAgICAgICAgdmFyIF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aDtcbiAgICAgICAgdGhpcy5nZXREZWZhdWx0TWluV2lkdGggPSAoX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdldERlZmF1bHRNaW5XaWR0aCkgIT09IG51bGwgJiYgX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoICE9PSB2b2lkIDAgPyBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggOiAoKT0+NzU7XG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gJDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkocHJvcHMsIHN0YXRlKSB7XG4gICAgbGV0IHsgZ2V0RGVmYXVsdFdpZHRoOiBnZXREZWZhdWx0V2lkdGgsIGdldERlZmF1bHRNaW5XaWR0aDogZ2V0RGVmYXVsdE1pbldpZHRoLCB0YWJsZVdpZHRoOiB0YWJsZVdpZHRoID0gMCB9ID0gcHJvcHM7XG4gICAgbGV0IFtyZXNpemluZ0NvbHVtbiwgc2V0UmVzaXppbmdDb2x1bW5dID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IGNvbHVtbkxheW91dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUpKHtcbiAgICAgICAgICAgIGdldERlZmF1bHRXaWR0aDogZ2V0RGVmYXVsdFdpZHRoLFxuICAgICAgICAgICAgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGhcbiAgICAgICAgfSksIFtcbiAgICAgICAgZ2V0RGVmYXVsdFdpZHRoLFxuICAgICAgICBnZXREZWZhdWx0TWluV2lkdGhcbiAgICBdKTtcbiAgICBsZXQgW2NvbnRyb2xsZWRDb2x1bW5zLCB1bmNvbnRyb2xsZWRDb2x1bW5zXSA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5zcGxpdENvbHVtbnNJbnRvQ29udHJvbGxlZEFuZFVuY29udHJvbGxlZChzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpLCBbXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgLy8gdW5jb250cm9sbGVkIGNvbHVtbiB3aWR0aHNcbiAgICBsZXQgW3VuY29udHJvbGxlZFdpZHRocywgc2V0VW5jb250cm9sbGVkV2lkdGhzXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKCgpPT5jb2x1bW5MYXlvdXQuZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKSk7XG4gICAgLy8gVXBkYXRlIHVuY29udHJvbGxlZCB3aWR0aHMgaWYgdGhlIGNvbHVtbnMgY2hhbmdlZC5cbiAgICBsZXQgW2xhc3RDb2x1bW5zLCBzZXRMYXN0Q29sdW1uc10gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpO1xuICAgIGlmIChzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMgIT09IGxhc3RDb2x1bW5zKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMubGVuZ3RoICE9PSBsYXN0Q29sdW1ucy5sZW5ndGggfHwgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLnNvbWUoKGMsIGkpPT5jLmtleSAhPT0gbGFzdENvbHVtbnNbaV0ua2V5KSkge1xuICAgICAgICAgICAgbGV0IG5ld1VuY29udHJvbGxlZFdpZHRocyA9IGNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpO1xuICAgICAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzKG5ld1VuY29udHJvbGxlZFdpZHRocyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGFzdENvbHVtbnMoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKTtcbiAgICB9XG4gICAgLy8gY29tYmluZSBjb2x1bW5zIGJhY2sgaW50byBvbmUgbWFwIHRoYXQgbWFpbnRhaW5zIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnNcbiAgICBsZXQgY29sV2lkdGhzID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnJlY29tYmluZUNvbHVtbnMoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLCB1bmNvbnRyb2xsZWRXaWR0aHMsIHVuY29udHJvbGxlZENvbHVtbnMsIGNvbnRyb2xsZWRDb2x1bW5zKSwgW1xuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsXG4gICAgICAgIHVuY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIGxldCBzdGFydFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChrZXkpPT57XG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uKGtleSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtblxuICAgIF0pO1xuICAgIGxldCB1cGRhdGVSZXNpemVkQ29sdW1ucyA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChrZXksIHdpZHRoKT0+e1xuICAgICAgICBsZXQgbmV3Q29udHJvbGxlZCA9IG5ldyBNYXAoQXJyYXkuZnJvbShjb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5LCBlbnRyeV0pPT5bXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGVudHJ5LnByb3BzLndpZHRoXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIGxldCBuZXdTaXplcyA9IGNvbHVtbkxheW91dC5yZXNpemVDb2x1bW5XaWR0aCh0YWJsZVdpZHRoLCBzdGF0ZS5jb2xsZWN0aW9uLCBuZXdDb250cm9sbGVkLCB1bmNvbnRyb2xsZWRXaWR0aHMsIGtleSwgd2lkdGgpO1xuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleV0pPT5bXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG5ld1NpemVzLmdldChrZXkpXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyhtYXApO1xuICAgICAgICByZXR1cm4gbmV3U2l6ZXM7XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICB0YWJsZVdpZHRoLFxuICAgICAgICBjb2x1bW5MYXlvdXQsXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24sXG4gICAgICAgIHVuY29udHJvbGxlZFdpZHRoc1xuICAgIF0pO1xuICAgIGxldCBlbmRSZXNpemUgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtbihudWxsKTtcbiAgICB9LCBbXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXG4gICAgXSk7XG4gICAgKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LmJ1aWxkQ29sdW1uV2lkdGhzKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIGNvbFdpZHRocyksIFtcbiAgICAgICAgdGFibGVXaWR0aCxcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcbiAgICAgICAgY29sV2lkdGhzLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICByZXR1cm4gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHJlc2l6aW5nQ29sdW1uOiByZXNpemluZ0NvbHVtbixcbiAgICAgICAgICAgIHVwZGF0ZVJlc2l6ZWRDb2x1bW5zOiB1cGRhdGVSZXNpemVkQ29sdW1ucyxcbiAgICAgICAgICAgIHN0YXJ0UmVzaXplOiBzdGFydFJlc2l6ZSxcbiAgICAgICAgICAgIGVuZFJlc2l6ZTogZW5kUmVzaXplLFxuICAgICAgICAgICAgZ2V0Q29sdW1uV2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uV2lkdGgoa2V5KSxcbiAgICAgICAgICAgIGdldENvbHVtbk1pbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1pbldpZHRoKGtleSksXG4gICAgICAgICAgICBnZXRDb2x1bW5NYXhXaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5NYXhXaWR0aChrZXkpLFxuICAgICAgICAgICAgdGFibGVTdGF0ZTogc3RhdGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgY29sdW1uTGF5b3V0LFxuICAgICAgICByZXNpemluZ0NvbHVtbixcbiAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnMsXG4gICAgICAgIHN0YXJ0UmVzaXplLFxuICAgICAgICBlbmRSZXNpemUsXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5sZXQgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xud2hpbGUoJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSA9PT0gJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHKSQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlKGtleU1hcCwgY29sdW1uTm9kZXMpIHtcbiAgICBpZiAoY29sdW1uTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1uTm9kZXMpe1xuICAgICAgICBsZXQgcGFyZW50S2V5ID0gY29sdW1uLnBhcmVudEtleTtcbiAgICAgICAgbGV0IGNvbCA9IFtcbiAgICAgICAgICAgIGNvbHVtblxuICAgICAgICBdO1xuICAgICAgICB3aGlsZShwYXJlbnRLZXkpe1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGtleU1hcC5nZXQocGFyZW50S2V5KTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KSBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgc2VlbiB0aGlzIHBhcmVudCwgdGhhbiBpdCBpcyBzaGFyZWRcbiAgICAgICAgICAgIC8vIHdpdGggYSBwcmV2aW91cyBjb2x1bW4uIElmIHRoZSBjdXJyZW50IGNvbHVtbiBpcyB0YWxsZXJcbiAgICAgICAgICAgIC8vIHRoYW4gdGhlIHByZXZpb3VzIGNvbHVtbiwgdGhhbiB3ZSBuZWVkIHRvIHNoaWZ0IHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGluIHRoZSBwcmV2aW91cyBjb2x1bW4gc28gaXQncyBsZXZlbCB3aXRoIHRoZSBjdXJyZW50IGNvbHVtbi5cbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbHNwYW4rKztcbiAgICAgICAgICAgICAgICBsZXQgeyBjb2x1bW46IGNvbHVtbiwgaW5kZXg6IGluZGV4IH0gPSBzZWVuLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IGNvbC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGluZGV4OyBpIDwgY29sLmxlbmd0aDsgaSsrKWNvbHVtbi5zcGxpY2UoaSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHNoaWZ0ZWQgaW5kaWNlc1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGNvbC5sZW5ndGg7IGkgPCBjb2x1bW4ubGVuZ3RoOyBpKyspLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5baV0gJiYgc2Vlbi5oYXMoY29sdW1uW2ldKSkgc2Vlbi5nZXQoY29sdW1uW2ldKS5pbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jb2xzcGFuID0gMTtcbiAgICAgICAgICAgICAgICBjb2wucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHNlZW4uc2V0KHBhcmVudCwge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRLZXkgPSBwYXJlbnQucGFyZW50S2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICBjb2x1bW4uaW5kZXggPSBjb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGxldCBtYXhMZW5ndGggPSBNYXRoLm1heCguLi5jb2x1bW5zLm1hcCgoYyk9PmMubGVuZ3RoKSk7XG4gICAgbGV0IGhlYWRlclJvd3MgPSBBcnJheShtYXhMZW5ndGgpLmZpbGwoMCkubWFwKCgpPT5bXSk7XG4gICAgLy8gQ29udmVydCBjb2x1bW5zIGludG8gcm93cy5cbiAgICBsZXQgY29sSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5zKXtcbiAgICAgICAgbGV0IGkgPSBtYXhMZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNvbHVtbil7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHNwYWNlIHVwIHVudGlsIHRoZSBjdXJyZW50IGNvbHVtbiB3aXRoIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gaGVhZGVyUm93c1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgcm93TGVuZ3RoID0gcm93LnJlZHVjZSgocCwgYyk9PnAgKyBjLmNvbHNwYW4sIDApO1xuICAgICAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPCBjb2xJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwicGxhY2Vob2xkZXItXCIgKyBpdGVtLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbEluZGV4IC0gcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0ubmV4dEtleSA9IHBsYWNlaG9sZGVyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLm5leHRLZXkgPSBpdGVtLmtleTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2S2V5ID0gcm93W3Jvdy5sZW5ndGggLSAxXS5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0ubGV2ZWwgPSBpO1xuICAgICAgICAgICAgICAgIGl0ZW0uY29sSW5kZXggPSBjb2xJbmRleDtcbiAgICAgICAgICAgICAgICByb3cucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb2xJbmRleCsrO1xuICAgIH1cbiAgICAvLyBBZGQgcGxhY2Vob2xkZXJzIGF0IHRoZSBlbmQgb2YgZWFjaCByb3cgdGhhdCBpcyBzaG9ydGVyIHRoYW4gdGhlIG1heGltdW1cbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgcm93IG9mIGhlYWRlclJvd3Mpe1xuICAgICAgICBsZXQgcm93TGVuZ3RoID0gcm93LnJlZHVjZSgocCwgYyk9PnAgKyBjLmNvbHNwYW4sIDApO1xuICAgICAgICBpZiAocm93TGVuZ3RoIDwgY29sdW1uTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJwbGFjZWhvbGRlci1cIiArIHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5LFxuICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbHVtbk5vZGVzLmxlbmd0aCAtIHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGxldmVsOiBpLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2S2V5OiByb3dbcm93Lmxlbmd0aCAtIDFdLmtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvdy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJSb3dzLm1hcCgoY2hpbGROb2RlcywgaW5kZXgpPT57XG4gICAgICAgIGxldCByb3cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlcnJvd1wiLFxuICAgICAgICAgICAga2V5OiBcImhlYWRlcnJvdy1cIiArIGluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9KTtcbn1cbmNsYXNzICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIGV4dGVuZHMgKDAsICQxQmZqVyRHcmlkQ29sbGVjdGlvbikge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm9keS5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgdmFyIF9nZXRGaXJzdEl0ZW07XG4gICAgICAgIHJldHVybiAoX2dldEZpcnN0SXRlbSA9ICgwLCAkMUJmalckZ2V0Rmlyc3RJdGVtKSh0aGlzLmJvZHkuY2hpbGROb2RlcykpID09PSBudWxsIHx8IF9nZXRGaXJzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRGaXJzdEl0ZW0ua2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICB2YXIgX2dldExhc3RJdGVtO1xuICAgICAgICByZXR1cm4gKF9nZXRMYXN0SXRlbSA9ICgwLCAkMUJmalckZ2V0TGFzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldExhc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TGFzdEl0ZW0ua2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRUZXh0VmFsdWUoa2V5KSB7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFyb3cpIHJldHVybiBcIlwiO1xuICAgICAgICAvLyBJZiB0aGUgcm93IGhhcyBhIHRleHRWYWx1ZSwgdXNlIHRoYXQuXG4gICAgICAgIGlmIChyb3cudGV4dFZhbHVlKSByZXR1cm4gcm93LnRleHRWYWx1ZTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbWJpbmUgdGhlIHRleHQgb2YgZWFjaCBvZiB0aGUgcm93IGhlYWRlciBjb2x1bW5zLlxuICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uS2V5cyA9IHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cztcbiAgICAgICAgaWYgKHJvd0hlYWRlckNvbHVtbktleXMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHJvdy5jaGlsZE5vZGVzKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gdGhpcy5jb2x1bW5zW2NlbGwuaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzLmhhcyhjb2x1bW4ua2V5KSAmJiBjZWxsLnRleHRWYWx1ZSkgdGV4dC5wdXNoKGNlbGwudGV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IHJvd0hlYWRlckNvbHVtbktleXMuc2l6ZSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iobm9kZXMsIHByZXYsIG9wdHMpe1xuICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgIC8vIEFkZCBjZWxsIGZvciBzZWxlY3Rpb24gY2hlY2tib3hlcyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGluZGV4OiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgPyAxIDogMCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNlbGwgZm9yIGRyYWcgYnV0dG9ucyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSB7XG4gICAgICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAga2V5OiAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgbGV0IGNvbHVtbktleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5LZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnByb3BzLmlzUm93SGVhZGVyKSByb3dIZWFkZXJDb2x1bW5LZXlzLmFkZChub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIml0ZW1cIjpcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRvIG5vdCBnbyBpbnRvIGNoaWxkTm9kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpdmlzaXQobm9kZSk7XG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUoY29sdW1uS2V5TWFwLCBjb2x1bW5zKTtcbiAgICAgICAgaGVhZGVyUm93cy5mb3JFYWNoKChyb3csIGkpPT5yb3dzLnNwbGljZShpLCAwLCByb3cpKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29sdW1uQ291bnQ6IGNvbHVtbnMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbXM6IHJvd3MsXG4gICAgICAgICAgICB2aXNpdE5vZGU6IChub2RlKT0+e1xuICAgICAgICAgICAgICAgIG5vZGUuY29sdW1uID0gY29sdW1uc1tub2RlLmluZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMgPSByb3dIZWFkZXJDb2x1bW5LZXlzO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmhlYWRlclJvd3MgPSBoZWFkZXJSb3dzO1xuICAgICAgICB0aGlzLl9zaXplID0gW1xuICAgICAgICAgICAgLi4uYm9keS5jaGlsZE5vZGVzXG4gICAgICAgIF0ubGVuZ3RoO1xuICAgICAgICAvLyBEZWZhdWx0IHJvdyBoZWFkZXIgY29sdW1uIHRvIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgIGlmICh0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuc2l6ZSA9PT0gMCkgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnMuZmluZCgoY29sdW1uKT0+e1xuICAgICAgICAgICAgdmFyIF9jb2x1bW5fcHJvcHMsIF9jb2x1bW5fcHJvcHMxO1xuICAgICAgICAgICAgcmV0dXJuICEoKF9jb2x1bW5fcHJvcHMgPSBjb2x1bW4ucHJvcHMpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2x1bW5fcHJvcHMuaXNEcmFnQnV0dG9uQ2VsbCkgJiYgISgoX2NvbHVtbl9wcm9wczEgPSBjb2x1bW4ucHJvcHMpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uX3Byb3BzMS5pc1NlbGVjdGlvbkNlbGwpO1xuICAgICAgICB9KS5rZXkpO1xuICAgIH1cbn1cblxuXG5cbmNvbnN0ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiA9IHtcbiAgICBhc2NlbmRpbmc6IFwiZGVzY2VuZGluZ1wiLFxuICAgIGRlc2NlbmRpbmc6IFwiYXNjZW5kaW5nXCJcbn07XG5mdW5jdGlvbiAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNihwcm9wcykge1xuICAgIGxldCBbaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCwgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWRdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyB9ID0gcHJvcHM7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzICYmIHNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29sdW1uczogW11cbiAgICAgICAgfSksIFtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBzaG93RHJhZ0J1dHRvbnNcbiAgICBdKTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKG5vZGVzLCBudWxsLCBjb250ZXh0KSwgW1xuICAgICAgICBjb250ZXh0XG4gICAgXSksIGNvbnRleHQpO1xuICAgIGxldCB7IGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJDFCZmpXJHVzZUdyaWRTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogcHJvcHMuZGlzYWJsZWRCZWhhdmlvciB8fCBcInNlbGVjdGlvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBwcm9wcy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyB8fCBmYWxzZSxcbiAgICAgICAgc29ydERlc2NyaXB0b3I6IHByb3BzLnNvcnREZXNjcmlwdG9yLFxuICAgICAgICBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBjb2xsZWN0aW9uLnNpemUgPT09IDAgfHwgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCxcbiAgICAgICAgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzb3J0IChjb2x1bW5LZXksIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9wcm9wc19zb3J0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHByb3BzLm9uU29ydENoYW5nZSh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5LZXksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gIT09IG51bGwgJiYgZGlyZWN0aW9uICE9PSB2b2lkIDAgPyBkaXJlY3Rpb24gOiAoKF9wcm9wc19zb3J0RGVzY3JpcHRvciA9IHByb3BzLnNvcnREZXNjcmlwdG9yKSA9PT0gbnVsbCB8fCBfcHJvcHNfc29ydERlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wc19zb3J0RGVzY3JpcHRvci5jb2x1bW4pID09PSBjb2x1bW5LZXkgPyAkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT05bcHJvcHMuc29ydERlc2NyaXB0b3IuZGlyZWN0aW9uXSA6IFwiYXNjZW5kaW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlci5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgY29sdW1uczogY29sdW1ucyB9ID0gcHJvcHM7XG4gICAgLy8gQ2xlYXIgY29sdW1ucyBzbyB0aGV5IGFyZW4ndCBkb3VibGUgYWRkZWQgaW4gc3RyaWN0IG1vZGUuXG4gICAgY29udGV4dC5jb2x1bW5zID0gW107XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghY29sdW1ucykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLmNvbHVtbnMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpeWllbGQge1xuICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXG4gICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY29sdW1uKT0+e1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNvbHVtblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCogY29sdW1ucztcbiAgICB9XG59O1xuLyoqXG4gKiBBIFRhYmxlSGVhZGVyIGlzIGEgY29udGFpbmVyIGZvciB0aGUgQ29sdW1uIGVsZW1lbnRzIGluIGEgVGFibGUuIENvbHVtbnMgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGNvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSA9ICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJib2R5XCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFRhYmxlQm9keSBpcyBhIGNvbnRhaW5lciBmb3IgdGhlIFJvdyBlbGVtZW50cyBvZiBhIFRhYmxlLiBSb3dzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWRcbiAqIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGBpdGVtc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3ID0gJDRhZTUzMTRiZjUwZGIxYTMkdmFyJFRhYmxlQm9keTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4sIGNoaWxkQ29sdW1uczogY2hpbGRDb2x1bW5zIH0gPSBwcm9wcztcbiAgICBsZXQgcmVuZGVyZWQgPSB0aXRsZSB8fCBjaGlsZHJlbjtcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgcmVuZGVyZWQgPT09IFwic3RyaW5nXCIgPyByZW5kZXJlZCA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXTtcbiAgICBsZXQgZnVsbE5vZGVzID0geWllbGQge1xuICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAhIWNoaWxkQ29sdW1ucyB8fCB0aXRsZSAmJiAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAwLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENvbHVtbnMpIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkQ29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZENvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRDb2x1bW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IGl0IHdvcmtzLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGVuIHRoZXJlJ3MgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgLy8gQnV0LCB3ZSBuZWVkIHRvIGtlZXAgdGhlIGxpc3Qgb2YgY29sdW1ucyBpbiB0aGUgbmV3IGNvbnRleHQgdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUNvbnRleHQobmV3Q29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB1cGRhdGVDb250ZXh0ID0gKGNvbnRleHQpPT57XG4gICAgICAgIC8vIHJlZ2lzdGVyIGxlYWYgY29sdW1ucyBvbiB0aGUgY29udGV4dCBzbyB0aGF0IDxSb3c+IGNhbiBhY2Nlc3MgdGhlbVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGZ1bGxOb2RlcylpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgY29udGV4dC5jb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpO1xufTtcbi8qKlxuICogQSBDb2x1bW4gcmVwcmVzZW50cyBhIGZpZWxkIG9mIGVhY2ggaXRlbSB3aXRoaW4gYSBUYWJsZS4gQ29sdW1ucyBtYXkgYWxzbyBjb250YWluIG5lc3RlZFxuICogQ29sdW1uIGVsZW1lbnRzIHRvIHJlcHJlc2VudCBjb2x1bW4gZ3JvdXBzLiBOZXN0ZWQgY29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzXG4gKiBjaGlsZHJlbiwgb3IgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGBjaGlsZENvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyA9ICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW47XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdyhwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdy5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsIFVOU1RBQkxFX2NoaWxkSXRlbXM6IFVOU1RBQkxFX2NoaWxkSXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY2VsbHMgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNob3dEcmFnQnV0dG9ucykgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXItZHJhZ1wiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgY29udGV4dC5zZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIikgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbnRleHQuY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZHJlbihjb2x1bW4ua2V5KSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5IC8vIHRoaXMgaXMgY29tYmluZWQgd2l0aCB0aGUgcm93IGtleSBieSBDb2xsZWN0aW9uQnVpbGRlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKFVOU1RBQkxFX2NoaWxkSXRlbXMpIGZvciAobGV0IGNoaWxkIG9mIFVOU1RBQkxFX2NoaWxkSXRlbXMpLy8gTm90ZTogaW4gb3JkZXIgdG8gcmV1c2UgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBUYWJsZUJvZHkgZm9yIG91ciBjaGlsZCByb3dzLCB3ZSBqdXN0IG5lZWQgdG8geWllbGQgYSB0eXBlIGFuZCBhIHZhbHVlIGhlcmUuIENvbGxlY3Rpb25CdWlsZGVyIHdpbGwgdGhlbiBsb29rIHVwXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCByZW5kZXJlciBhbmQgdXNlIHRoYXQgdG8gYnVpbGQgdGhlIGZ1bGwgbm9kZSBvZiB0aGlzIGNoaWxkIHJvdywgdXNpbmcgdGhlIHZhbHVlIHByb3ZpZGVkIGhlcmUgdG8gZ2VuZXJhdGUgdGhlIGNlbGxzXG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUm93cyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChub2RlKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoIDwgY29udGV4dC5jb2x1bW5zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIG9mIGEgUm93J3MgY2hpbGQgQ2VsbHMgbXVzdCBiZSBwb3NpdGlvbmVkIGJlZm9yZSBhbnkgY2hpbGQgUm93cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFJvd3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBjZWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYENlbGwgY291bnQgbXVzdCBtYXRjaCBjb2x1bW4gY291bnQuIEZvdW5kICR7Y2VsbHMubGVuZ3RofSBjZWxscyBhbmQgJHtjb250ZXh0LmNvbHVtbnMubGVuZ3RofSBjb2x1bW5zLmApO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjZWxscztcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRSb3dzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCByb3dzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29udGV4dC5jb2x1bW5zLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCB8fCBuZXdDb250ZXh0LmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBjb250ZXh0LmNvbHVtbnNbaV0ua2V5KSB8fCBuZXdDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzICE9PSBjb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IG5ld0NvbnRleHQuc2hvd0RyYWdCdXR0b25zICE9PSBjb250ZXh0LnNob3dEcmFnQnV0dG9ucyB8fCBuZXdDb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IGNvbnRleHQuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFJvdyByZXByZXNlbnRzIGEgc2luZ2xlIGl0ZW0gaW4gYSBUYWJsZSBhbmQgY29udGFpbnMgQ2VsbCBlbGVtZW50cyBmb3IgZWFjaCBjb2x1bW4uXG4gKiBDZWxscyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvblxuICogYmFzZWQgb24gdGhlIGNvbHVtbnMgZGVmaW5lZCBpbiB0aGUgVGFibGVIZWFkZXIuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiA9ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3c7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbC5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiID8gY2hpbGRyZW4gOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlbixcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlXG4gICAgfTtcbn07XG4vKipcbiAqIEEgQ2VsbCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBDb2x1bW4gd2l0aGluIGEgVGFibGUgUm93LlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgPSAkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbDtcblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQocHJvcHMpIHtcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcywgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsIFVOU1RBQkxFX2V4cGFuZGVkS2V5czogcHJvcEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5czogcHJvcERlZmF1bHRFeHBhbmRlZEtleXMsIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2U6IFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgaWYgKCEoMCwgJDFCZmpXJHRhYmxlTmVzdGVkUm93cykoKSkgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBmbGFnIGZvciB0YWJsZSBuZXN0ZWQgcm93cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIHVzZVRyZWVHcmlkU3RhdGUuXCIpO1xuICAgIGxldCBbZXhwYW5kZWRLZXlzLCBzZXRFeHBhbmRlZEtleXNdID0gKDAsICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BFeHBhbmRlZEtleXMgPyAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKHByb3BFeHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcERlZmF1bHRFeHBhbmRlZEtleXMpIDogbmV3IFNldCgpLCBVTlNUQUJMRV9vbkV4cGFuZGVkQ2hhbmdlKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBidWlsZGVyID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIpKCksIFtdKTtcbiAgICBsZXQgbm9kZXMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5idWlsZGVyLmJ1aWxkKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9LCBjb250ZXh0KSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29udGV4dFxuICAgIF0pO1xuICAgIGxldCB0cmVlR3JpZENvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXNcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBub2RlcyxcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgZXhwYW5kZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IG9uVG9nZ2xlID0gKGtleSk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzKCRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoZXhwYW5kZWRLZXlzLCBrZXksIHRyZWVHcmlkQ29sbGVjdGlvbikpO1xuICAgIH07XG4gICAgbGV0IGNvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwKSh0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2RlcywgbnVsbCwgY29udGV4dCk7XG4gICAgfSwgW1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2Rlc1xuICAgIF0pO1xuICAgIGxldCB0YWJsZVN0YXRlID0gKDAsICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGFibGVTdGF0ZSxcbiAgICAgICAga2V5TWFwOiB0cmVlR3JpZENvbGxlY3Rpb24ua2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHRyZWVHcmlkQ29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxuICAgICAgICB0b2dnbGVLZXk6IG9uVG9nZ2xlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoY3VycmVudEV4cGFuZGVkS2V5cywga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgbGV0IHVwZGF0ZWRFeHBhbmRlZEtleXM7XG4gICAgaWYgKGN1cnJlbnRFeHBhbmRlZEtleXMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoY29sbGVjdGlvbi5mbGF0dGVuZWRSb3dzLmZpbHRlcigocm93KT0+cm93LnByb3BzLlVOU1RBQkxFX2NoaWxkSXRlbXMgfHwgcm93LnByb3BzLmNoaWxkcmVuLmxlbmd0aCA+IGNvbGxlY3Rpb24udXNlckNvbHVtbkNvdW50KS5tYXAoKHJvdyk9PnJvdy5rZXkpKTtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjdXJyZW50RXhwYW5kZWRLZXlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZWRFeHBhbmRlZEtleXMuaGFzKGtleSkpIHVwZGF0ZWRFeHBhbmRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgdXBkYXRlZEV4cGFuZGVkS2V5cy5hZGQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZWRFeHBhbmRlZEtleXM7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKGV4cGFuZGVkKSB7XG4gICAgaWYgKCFleHBhbmRlZCkgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZXhwYW5kZWQgPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3IFNldChleHBhbmRlZCk7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIG9wdHMpIHtcbiAgICBsZXQgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoKSB9ID0gb3B0cztcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgZmxhdHRlbmVkUm93cyA9IFtdO1xuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IHVzZXJDb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IG9yaWdpbmFsQ29sdW1ucyA9IFtdO1xuICAgIGxldCBrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykgY29sdW1uQ291bnQrKztcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgY29sdW1uQ291bnQrKztcbiAgICBsZXQgdG9wTGV2ZWxSb3dzID0gW107XG4gICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICBib2R5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBrZXlNYXAuc2V0KGJvZHkua2V5LCBib2R5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgdXNlckNvbHVtbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgIHRvcExldmVsUm93cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiY29sdW1uXCIpIG9yaWdpbmFsQ29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICB2aXNpdChub2RlKTtcbiAgICB9XG4gICAgY29sdW1uQ291bnQgKz0gdXNlckNvbHVtbkNvdW50O1xuICAgIC8vIFVwZGF0ZSBlYWNoIGdyaWQgbm9kZSBpbiB0aGUgdHJlZWdyaWQgdGFibGUgd2l0aCB2YWx1ZXMgc3BlY2lmaWMgdG8gYSB0cmVlZ3JpZCBzdHJ1Y3R1cmUuIEFsc28gc3RvcmUgYSBzZXQgb2YgZmxhdHRlbmVkIHJvdyBub2RlcyBmb3IgVGFibGVDb2xsZWN0aW9uIHRvIGNvbnN1bWVcbiAgICBsZXQgZ2xvYmFsUm93Q291bnQgPSAwO1xuICAgIGxldCB2aXNpdE5vZGUgPSAobm9kZSwgaSk9PntcbiAgICAgICAgLy8gQ2xvbmUgcm93IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBzbyBtb2RpZmljYXRpb25zIHRvIHRoZSBub2RlIGZvciB0cmVlZ3JpZCBzcGVjaWZpYyB2YWx1ZXMgYXJlbid0IGFwcGxpZWQgb24gdGhlIG5vZGVzIHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIFRhYmxlQ29sbGVjdGlvbi4gSW5kZXgsIGxldmVsLCBhbmQgcGFyZW50IGtleXMgYXJlIGFsbCBjaGFuZ2VkIHRvIHJlZmxlY3QgYSBmbGF0dGVuZWQgcm93IHN0cnVjdHVyZSByYXRoZXIgdGhhbiB0aGUgdHJlZWdyaWQgc3RydWN0dXJlXG4gICAgICAgIC8vIHZhbHVlcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgdmlhIENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmIChjaGlsZC50eXBlID09PSBcImNlbGxcIikge1xuICAgICAgICAgICAgICAgIGxldCBjZWxsQ2xvbmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbENsb25lLmluZGV4ICsgMSA9PT0gY29sdW1uQ291bnQpIGNlbGxDbG9uZS5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAuLi5jZWxsQ2xvbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5OiBib2R5LmtleSxcbiAgICAgICAgICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgICAgICAgICBpbmRleDogZ2xvYmFsUm93Q291bnQrK1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1Byb3BzID0ge307XG4gICAgICAgIC8vIEFzc2lnbiBpbmRleE9mVHlwZSB0byBjZWxscyBhbmQgcm93cyBmb3IgYXJpYS1wb3NpbnNldFxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcInBsYWNlaG9sZGVyXCIgJiYgbm9kZS50eXBlICE9PSBcImNvbHVtblwiKSBuZXdQcm9wc1tcImluZGV4T2ZUeXBlXCJdID0gaTtcbiAgICAgICAgLy8gVXNlIE9iamVjdC5hc3NpZ24gaW5zdGVhZCBvZiBzcHJlYWQgdG8gcHJlc2VydmUgb2JqZWN0IHJlZmVyZW5jZSBmb3Iga2V5TWFwLiBBbHNvIGVuc3VyZXMgcmV0cmlldmluZyBub2Rlc1xuICAgICAgICAvLyB2aWEgLmNoaWxkTm9kZXMgcmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIG9uZSBmb3VuZCB2aWEga2V5TWFwIGxvb2sgdXBcbiAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCBuZXdQcm9wcyk7XG4gICAgICAgIGtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAoIShjaGlsZC50eXBlID09PSBcIml0ZW1cIiAmJiBleHBhbmRlZEtleXMgIT09IFwiYWxsXCIgJiYgIWV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwvZXhwYW5kZWQgcm93L2NvbHVtbiBhbmQgdGhlIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGxhc3ROb2RlLm5leHRLZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3ROb2RlLmtleTtcbiAgICAgICAgICAgIH0gZWxzZSBjaGlsZC5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcIml0ZW1cIikgdmlzaXROb2RlKGNoaWxkLCByb3dJbmRleCsrKTtcbiAgICAgICAgICAgIGVsc2UgLy8gV2UgZW5mb3JjZSB0aGF0IHRoZSBjZWxscyBjb21lIGJlZm9yZSByb3dzIHNvIGNhbiBqdXN0IHJldXNlIGNlbGwgaW5kZXhcbiAgICAgICAgICAgIHZpc2l0Tm9kZShjaGlsZCwgY2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGUpIGxhc3ROb2RlLm5leHRLZXkgPSBudWxsO1xuICAgIH07XG4gICAgbGV0IGxhc3Q7XG4gICAgdG9wTGV2ZWxSb3dzLmZvckVhY2goKG5vZGUsIGkpPT57XG4gICAgICAgIHZpc2l0Tm9kZShub2RlLCBpKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgIH0gZWxzZSBub2RlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICB9KTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlNYXA6IGtleU1hcCxcbiAgICAgICAgdXNlckNvbHVtbkNvdW50OiB1c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGZsYXR0ZW5lZFJvd3M6IGZsYXR0ZW5lZFJvd3MsXG4gICAgICAgIHRhYmxlTm9kZXM6IFtcbiAgICAgICAgICAgIC4uLm9yaWdpbmFsQ29sdW1ucyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZsYXR0ZW5lZFJvd3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkgYXMgdXNlVGFibGVDb2x1bW5SZXNpemVTdGF0ZSwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYgYXMgdXNlVGFibGVTdGF0ZSwgJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUgYXMgVGFibGVIZWFkZXIsICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3IGFzIFRhYmxlQm9keSwgJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMgYXMgQ29sdW1uLCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiBhcyBSb3csICQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIGFzIENlbGwsICQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIGFzIFNlY3Rpb24sICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIGFzIFRhYmxlQ29sbGVjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUgYXMgYnVpbGRIZWFkZXJSb3dzLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSBhcyBUYWJsZUNvbHVtbkxheW91dCwgJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQgYXMgVU5TVEFCTEVfdXNlVHJlZUdyaWRTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) // directly set selection because replace/toggle selection won't consider disabled keys\n            selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQ25COztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix5RUFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsOEZBQThGO0FBQ3hHLDhCQUE4Qix5Q0FBYTtBQUMzQyxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS29FO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkZGl0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYnMvZGlzdC9pbXBvcnQubWpzPzllY2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUgYXMgJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2xpc3RcIjtcbmltcG9ydCB7dXNlUmVmIGFzICRpakhLWiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkaWpIS1okdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDc2ZjkxOWEwNGM1YTdkMTQkZXhwb3J0JDRiYTA3MWRhZjRlNDg2KHByb3BzKSB7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXk7XG4gICAgbGV0IHN0YXRlID0gKDAsICRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkS2V5OiAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6ICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KHByb3BzLmNvbGxlY3Rpb24sIHByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSlcbiAgICB9KTtcbiAgICBsZXQgeyBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBzZWxlY3RlZEtleTogY3VycmVudFNlbGVjdGVkS2V5IH0gPSBzdGF0ZTtcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5ID0gKDAsICRpakhLWiR1c2VSZWYpKGN1cnJlbnRTZWxlY3RlZEtleSk7XG4gICAgKDAsICRpakhLWiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIEVuc3VyZSBhIHRhYiBpcyBhbHdheXMgc2VsZWN0ZWQgKGluIGNhc2Ugbm8gc2VsZWN0ZWQga2V5IHdhcyBzcGVjaWZpZWQgb3IgaWYgc2VsZWN0ZWQgaXRlbSB3YXMgZGVsZXRlZCBmcm9tIGNvbGxlY3Rpb24pXG4gICAgICAgIGxldCBzZWxlY3RlZEtleSA9IGN1cnJlbnRTZWxlY3RlZEtleTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbk1hbmFnZXIuaXNFbXB0eSB8fCAhY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXkgPSAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShjb2xsZWN0aW9uLCBzdGF0ZS5kaXNhYmxlZEtleXMpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwpIC8vIGRpcmVjdGx5IHNldCBzZWxlY3Rpb24gYmVjYXVzZSByZXBsYWNlL3RvZ2dsZSBzZWxlY3Rpb24gd29uJ3QgY29uc2lkZXIgZGlzYWJsZWQga2V5c1xuICAgICAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRTZWxlY3RlZEtleXMoW1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdGFibGlzdCBkb2Vzbid0IGhhdmUgZm9jdXMgYW5kIHRoZSBzZWxlY3RlZCBrZXkgY2hhbmdlcyBvciBpZiB0aGVyZSBpc24ndCBhIGZvY3VzZWQga2V5IHlldCwgY2hhbmdlIGZvY3VzZWQga2V5IHRvIHRoZSBzZWxlY3RlZCBrZXkgaWYgaXQgZXhpc3RzLlxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT0gbnVsbCAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgPT0gbnVsbCB8fCAhc2VsZWN0aW9uTWFuYWdlci5pc0ZvY3VzZWQgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWRLZXkoc2VsZWN0ZWRLZXkpO1xuICAgICAgICBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCA9IHNlbGVjdGVkS2V5O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KGNvbGxlY3Rpb24sIGRpc2FibGVkS2V5cykge1xuICAgIGxldCBzZWxlY3RlZEtleSA9IG51bGw7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEZpcnN0S2V5KCk7XG4gICAgICAgIC8vIGxvb3Agb3ZlciB0YWJzIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgaXNuJ3QgZGlzYWJsZWQgYW5kIHNlbGVjdCB0aGF0XG4gICAgICAgIHdoaWxlKGRpc2FibGVkS2V5cy5oYXMoc2VsZWN0ZWRLZXkpICYmIHNlbGVjdGVkS2V5ICE9PSBjb2xsZWN0aW9uLmdldExhc3RLZXkoKSlzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoc2VsZWN0ZWRLZXkpO1xuICAgICAgICAvLyBpZiB0aGlzIGNoZWNrIGlzIHRydWUsIHRoZW4gZXZlcnkgaXRlbSBpcyBkaXNhYmxlZCwgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byBkZWZhdWx0IHRvIHRoZSBmaXJzdCBrZXkgdGhhbiB0aGUgbGFzdFxuICAgICAgICBpZiAoZGlzYWJsZWRLZXlzLmhhcyhzZWxlY3RlZEtleSkgJiYgc2VsZWN0ZWRLZXkgPT09IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpKSBzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkS2V5O1xufVxuXG5cblxuXG5leHBvcnQgeyQ3NmY5MTlhMDRjNWE3ZDE0JGV4cG9ydCQ0YmEwNzFkYWY0ZTQ4NiBhcyB1c2VUYWJMaXN0U3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQSx3Q0FBd0Msb0VBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLcUU7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcz85NDI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRiT2thZSR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGlzUmVhZE9ubHk6IGlzUmVhZE9ubHkgfSA9IHByb3BzO1xuICAgIC8vIGhhdmUgdG8gcHJvdmlkZSBhbiBlbXB0eSBmdW5jdGlvbiBzbyB1c2VDb250cm9sbGVkU3RhdGUgZG9lc24ndCB0aHJvdyBhIGZpdFxuICAgIC8vIGNhbid0IHVzZSB1c2VDb250cm9sbGVkU3RhdGUncyBwcm9wIGNhbGxpbmcgYmVjYXVzZSB3ZSBuZWVkIHRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgY2hhbmdlXG4gICAgbGV0IFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSAoMCwgJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNTZWxlY3RlZCwgcHJvcHMuZGVmYXVsdFNlbGVjdGVkIHx8IGZhbHNlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSBzZXRTZWxlY3RlZCh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZVN0YXRlKCkge1xuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHNldFNlbGVjdGVkKCFpc1NlbGVjdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICAgICAgc2V0U2VsZWN0ZWQ6IHVwZGF0ZVNlbGVjdGVkLFxuICAgICAgICB0b2dnbGU6IHRvZ2dsZVN0YXRlXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMzAxN2ZhN2ZmZGRkZWM3NCRleHBvcnQkODA0MmM2YzAxM2ZkNTIyNiBhcyB1c2VUb2dnbGVTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFVBQVUsc0hBQXNIO0FBQ2hJLFVBQVUsMkNBQTJDLE1BQU0sMkVBQTZCO0FBQ3hGLGlCQUFpQiwwQ0FBYyxTQUFTLGtDQUFrQztBQUMxRSwyQkFBMkIseUNBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7OztBQUs2RTtBQUM3RSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90b29sdGlwL2Rpc3QvaW1wb3J0Lm1qcz8xMGQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTWVtbyBhcyAkMU9oRHEkdXNlTWVtbywgdXNlUmVmIGFzICQxT2hEcSR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkMU9oRHEkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0RFTEFZID0gMTUwMDsgLy8gdGhpcyBzZWVtcyB0byBiZSBhIDEuNSBzZWNvbmQgZGVsYXksIGNoZWNrIHdpdGggZGVzaWduXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiA9IDUwMDtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMgPSB7fTtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkID0gMDtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG5mdW5jdGlvbiAkODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgZGVsYXk6IGRlbGF5ID0gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfREVMQVksIGNsb3NlRGVsYXk6IGNsb3NlRGVsYXkgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiB9ID0gcHJvcHM7XG4gICAgbGV0IHsgaXNPcGVuOiBpc09wZW4sIG9wZW46IG9wZW4sIGNsb3NlOiBjbG9zZSB9ID0gKDAsICQxT2hEcSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGlkID0gKDAsICQxT2hEcSR1c2VNZW1vKSgoKT0+YCR7KyskODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkfWAsIFtdKTtcbiAgICBsZXQgY2xvc2VUaW1lb3V0ID0gKDAsICQxT2hEcSR1c2VSZWYpKCk7XG4gICAgbGV0IGVuc3VyZVRvb2x0aXBFbnRyeSA9ICgpPT57XG4gICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF0gPSBoaWRlVG9vbHRpcDtcbiAgICB9O1xuICAgIGxldCBjbG9zZU9wZW5Ub29sdGlwcyA9ICgpPT57XG4gICAgICAgIGZvcihsZXQgaGlkZVRvb2x0aXBJZCBpbiAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMpaWYgKGhpZGVUb29sdGlwSWQgIT09IGlkKSB7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaGlkZVRvb2x0aXBJZF0odHJ1ZSk7XG4gICAgICAgICAgICBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2hpZGVUb29sdGlwSWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc2hvd1Rvb2x0aXAgPSAoKT0+e1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICBjbG9zZVRpbWVvdXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGNsb3NlT3BlblRvb2x0aXBzKCk7XG4gICAgICAgIGVuc3VyZVRvb2x0aXBFbnRyeSgpO1xuICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSB0cnVlO1xuICAgICAgICBvcGVuKCk7XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBoaWRlVG9vbHRpcCA9IChpbW1lZGlhdGUpPT57XG4gICAgICAgIGlmIChpbW1lZGlhdGUgfHwgY2xvc2VEZWxheSA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2xvc2VUaW1lb3V0LmN1cnJlbnQpIGNsb3NlVGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSwgY2xvc2VEZWxheSk7XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwKSB7XG4gICAgICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCkgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXTtcbiAgICAgICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIE1hdGgubWF4KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOLCBjbG9zZURlbGF5KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB3YXJtdXBUb29sdGlwID0gKCk9PntcbiAgICAgICAgY2xvc2VPcGVuVG9vbHRpcHMoKTtcbiAgICAgICAgZW5zdXJlVG9vbHRpcEVudHJ5KCk7XG4gICAgICAgIGlmICghaXNPcGVuICYmICEkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCAmJiAhJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwKSAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IHRydWU7XG4gICAgICAgICAgICBzaG93VG9vbHRpcCgpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGVsc2UgaWYgKCFpc09wZW4pIHNob3dUb29sdGlwKCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkMU9oRHEkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQuY3VycmVudCk7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgICAgICBpZiAodG9vbHRpcCkgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpZFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICBvcGVuOiAoaW1tZWRpYXRlKT0+e1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgZGVsYXkgPiAwICYmICFjbG9zZVRpbWVvdXQuY3VycmVudCkgd2FybXVwVG9vbHRpcCgpO1xuICAgICAgICAgICAgZWxzZSBzaG93VG9vbHRpcCgpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogaGlkZVRvb2x0aXBcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQ4Nzk2ZjkwNzM2ZTE3NWNiJGV4cG9ydCQ0ZDQwNjU5YzI1ZWNiNTBiIGFzIHVzZVRvb2x0aXBUcmlnZ2VyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\n\n\n\n\n\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9KO0FBQ2xDO0FBQ2pDO0FBQ0k7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QixJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBLDhDQUE4QyxvRUFBeUI7QUFDdkUsNkJBQTZCLCtFQUFnQztBQUM3RCwyQkFBMkIsMENBQWM7QUFDekM7QUFDQTtBQUNBLG1CQUFtQixxRUFBb0IsYUFBYSw4Q0FBa0I7QUFDdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0VBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1nSTtBQUNoSSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGRpdC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90cmVlL2Rpc3QvaW1wb3J0Lm1qcz85OTkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkMU9vVGokdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkMU9vVGokU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICQxT29UaiR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkMU9vVGokdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCBhcyAkMU9vVGokdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29sbGVjdGlvbiBhcyAkMU9vVGokdXNlQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0S2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyB9ID0ge30pe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xuICAgICAgICBleHBhbmRlZEtleXMgPSBleHBhbmRlZEtleXMgfHwgbmV3IFNldCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIChub2RlLnR5cGUgPT09IFwic2VjdGlvblwiIHx8IGV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSBub2RlLmluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xuICAgICAgICAgICAgLy8gU2V0IG5leHRLZXkgYXMgdW5kZWZpbmVkIHNpbmNlIHRoaXMgbWlnaHQgYmUgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgdGhlIGxhc3Qgbm9kZSwgbGFzdC5uZXh0S2V5IHdpbGwgcHJvcGVybHkgc2V0IGF0IHN0YXJ0IG9mIG5ldyBsb29wXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0S2V5ID0gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG59XG5cblxuXG5cblxuZnVuY3Rpb24gJDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYocHJvcHMpIHtcbiAgICBsZXQgW2V4cGFuZGVkS2V5cywgc2V0RXhwYW5kZWRLZXlzXSA9ICgwLCAkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5leHBhbmRlZEtleXMgPyBuZXcgU2V0KHByb3BzLmV4cGFuZGVkS2V5cykgOiB1bmRlZmluZWQsIHByb3BzLmRlZmF1bHRFeHBhbmRlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRlZmF1bHRFeHBhbmRlZEtleXMpIDogbmV3IFNldCgpLCBwcm9wcy5vbkV4cGFuZGVkQ2hhbmdlKTtcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICQxT29UaiR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCB0cmVlID0gKDAsICQxT29UaiR1c2VDb2xsZWN0aW9uKShwcm9wcywgKDAsICQxT29UaiR1c2VDYWxsYmFjaykoKG5vZGVzKT0+bmV3ICgwLCAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSkobm9kZXMsIHtcbiAgICAgICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGV4cGFuZGVkS2V5c1xuICAgIF0pLCBudWxsKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICgwLCAkMU9vVGokdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICF0cmVlLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxuICAgIF0pO1xuICAgIGxldCBvblRvZ2dsZSA9IChrZXkpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5cygkODc1ZDY2OTNlMTJhZjA3MSR2YXIkdG9nZ2xlS2V5KGV4cGFuZGVkS2V5cywga2V5KSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiB0cmVlLFxuICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyxcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGUsXG4gICAgICAgIHNldEV4cGFuZGVkS2V5czogc2V0RXhwYW5kZWRLZXlzLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBuZXcgKDAsICQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyKSh0cmVlLCBzZWxlY3Rpb25TdGF0ZSlcbiAgICB9O1xufVxuZnVuY3Rpb24gJDg3NWQ2NjkzZTEyYWYwNzEkdmFyJHRvZ2dsZUtleShzZXQsIGtleSkge1xuICAgIGxldCByZXMgPSBuZXcgU2V0KHNldCk7XG4gICAgaWYgKHJlcy5oYXMoa2V5KSkgcmVzLmRlbGV0ZShrZXkpO1xuICAgIGVsc2UgcmVzLmFkZChrZXkpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuXG5cblxuZXhwb3J0IHskODc1ZDY2OTNlMTJhZjA3MSRleHBvcnQkNzI4ZDZiYTUzNDQwMzc1NiBhcyB1c2VUcmVlU3RhdGUsICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhIGFzIFRyZWVDb2xsZWN0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // If uncontrolled, mutate the currentValue local variable so that\n            // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJOztBQUU3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBZTtBQUN6RCw4QkFBOEIseUNBQWE7QUFDM0M7QUFDQSxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBLDJGQUEyRiwrQ0FBK0MsS0FBSyw2Q0FBNkM7QUFDNUw7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLc1A7QUFDdFAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzP2M2ODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkNmltdWgkdXNlU3RhdGUsIHVzZVJlZiBhcyAkNmltdWgkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDZpbXVoJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJDZpbXVoJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1KHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKSB7XG4gICAgbGV0IFtzdGF0ZVZhbHVlLCBzZXRTdGF0ZVZhbHVlXSA9ICgwLCAkNmltdWgkdXNlU3RhdGUpKHZhbHVlIHx8IGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IGlzQ29udHJvbGxlZFJlZiA9ICgwLCAkNmltdWgkdXNlUmVmKSh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBsZXQgaXNDb250cm9sbGVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAoMCwgJDZpbXVoJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IHdhc0NvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHdhc0NvbnRyb2xsZWQgIT09IGlzQ29udHJvbGxlZCkgY29uc29sZS53YXJuKGBXQVJOOiBBIGNvbXBvbmVudCBjaGFuZ2VkIGZyb20gJHt3YXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifSB0byAke2lzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0uYCk7XG4gICAgICAgIGlzQ29udHJvbGxlZFJlZi5jdXJyZW50ID0gaXNDb250cm9sbGVkO1xuICAgIH0sIFtcbiAgICAgICAgaXNDb250cm9sbGVkXG4gICAgXSk7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGlzQ29udHJvbGxlZCA/IHZhbHVlIDogc3RhdGVWYWx1ZTtcbiAgICBsZXQgc2V0VmFsdWUgPSAoMCwgJDZpbXVoJHVzZUNhbGxiYWNrKSgodmFsdWUsIC4uLmFyZ3MpPT57XG4gICAgICAgIGxldCBvbkNoYW5nZUNhbGxlciA9ICh2YWx1ZSwgLi4ub25DaGFuZ2VBcmdzKT0+e1xuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaXMoY3VycmVudFZhbHVlLCB2YWx1ZSkpIG9uQ2hhbmdlKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIC8vIElmIHVuY29udHJvbGxlZCwgbXV0YXRlIHRoZSBjdXJyZW50VmFsdWUgbG9jYWwgdmFyaWFibGUgc28gdGhhdFxuICAgICAgICAgICAgLy8gY2FsbGluZyBzZXRTdGF0ZSBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIHZhbHVlIG9ubHkgZW1pdHMgb25DaGFuZ2Ugb25jZS5cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSByZWYgZm9yIHRoaXMgYmVjYXVzZSB3ZSBzcGVjaWZpY2FsbHkgX2RvXyB3YW50IHRoZSB2YWx1ZSB0b1xuICAgICAgICAgICAgLy8gcmVzZXQgZXZlcnkgcmVuZGVyLCBhbmQgYXNzaWduaW5nIHRvIGEgcmVmIGluIHJlbmRlciBicmVha3MgYWJvcnRlZCBzdXNwZW5kZWQgcmVuZGVycy5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldlIGNhbiBub3Qgc3VwcG9ydCBhIGZ1bmN0aW9uIGNhbGxiYWNrLiBTZWUgR2l0aHViIElzc3VlcyBmb3IgZGV0YWlscyBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vaXNzdWVzLzIzMjBcIik7XG4gICAgICAgICAgICAvLyB0aGlzIHN1cHBvcnRzIGZ1bmN0aW9uYWwgdXBkYXRlcyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjZnVuY3Rpb25hbC11cGRhdGVzXG4gICAgICAgICAgICAvLyB3aGVuIHNvbWVvbmUgdXNpbmcgdXNlQ29udHJvbGxlZFN0YXRlIGNhbGxzIHNldENvbnRyb2xsZWRTdGF0ZShteUZ1bmMpXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY2FsbCBvdXIgdXNlU3RhdGUgc2V0U3RhdGUgd2l0aCBhIGZ1bmN0aW9uIGFzIHdlbGwgd2hpY2ggaW52b2tlcyBteUZ1bmMgYW5kIGNhbGxzIG9uQ2hhbmdlIHdpdGggdGhlIHZhbHVlIGZyb20gbXlGdW5jXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBhbiB1bmNvbnRyb2xsZWQgc3RhdGUsIHRoZW4gd2UgYWxzbyByZXR1cm4gdGhlIHZhbHVlIG9mIG15RnVuYyB3aGljaCB0byBzZXRTdGF0ZSBsb29rcyBhcyB0aG91Z2ggaXQgd2FzIGp1c3QgY2FsbGVkIHdpdGggbXlGdW5jIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBjb250cm9sbGVkIHZhbHVlLCB3aGljaCB3b24ndCBjYXVzZSBhIHJlcmVuZGVyIGJlY2F1c2UgUmVhY3Qga25vd3MgdG8gYmFpbCBvdXQgd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jdGlvbiA9IChvbGRWYWx1ZSwgLi4uZnVuY3Rpb25BcmdzKT0+e1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmNlcHRlZFZhbHVlID0gdmFsdWUoaXNDb250cm9sbGVkID8gY3VycmVudFZhbHVlIDogb2xkVmFsdWUsIC4uLmZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIoaW50ZXJjZXB0ZWRWYWx1ZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHJldHVybiBpbnRlcmNlcHRlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRTdGF0ZVZhbHVlKHVwZGF0ZUZ1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSBzZXRTdGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGVyKHZhbHVlLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNDb250cm9sbGVkLFxuICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgIG9uQ2hhbmdlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICBzZXRWYWx1ZVxuICAgIF07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qKlxuICogVGFrZXMgYSB2YWx1ZSBhbmQgZm9yY2VzIGl0IHRvIHRoZSBjbG9zZXN0IG1pbi9tYXggaWYgaXQncyBvdXRzaWRlLiBBbHNvIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCB2YWxpZCBzdGVwLlxuICovIGZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0KHZhbHVlLCBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5KSB7XG4gICAgbGV0IG5ld1ZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjModmFsdWUsIG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgbWluID0gTnVtYmVyKG1pbik7XG4gICAgbWF4ID0gTnVtYmVyKG1heCk7XG4gICAgbGV0IHJlbWFpbmRlciA9ICh2YWx1ZSAtIChpc05hTihtaW4pID8gMCA6IG1pbikpICUgc3RlcDtcbiAgICBsZXQgc25hcHBlZFZhbHVlID0gTWF0aC5hYnMocmVtYWluZGVyKSAqIDIgPj0gc3RlcCA/IHZhbHVlICsgTWF0aC5zaWduKHJlbWFpbmRlcikgKiAoc3RlcCAtIE1hdGguYWJzKHJlbWFpbmRlcikpIDogdmFsdWUgLSByZW1haW5kZXI7XG4gICAgaWYgKCFpc05hTihtaW4pKSB7XG4gICAgICAgIGlmIChzbmFwcGVkVmFsdWUgPCBtaW4pIHNuYXBwZWRWYWx1ZSA9IG1pbjtcbiAgICAgICAgZWxzZSBpZiAoIWlzTmFOKG1heCkgJiYgc25hcHBlZFZhbHVlID4gbWF4KSBzbmFwcGVkVmFsdWUgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gc3RlcCkgKiBzdGVwO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1heCkgJiYgc25hcHBlZFZhbHVlID4gbWF4KSBzbmFwcGVkVmFsdWUgPSBNYXRoLmZsb29yKG1heCAvIHN0ZXApICogc3RlcDtcbiAgICAvLyBjb3JyZWN0IGZsb2F0aW5nIHBvaW50IGJlaGF2aW9yIGJ5IHJvdW5kaW5nIHRvIHN0ZXAgcHJlY2lzaW9uXG4gICAgbGV0IHN0cmluZyA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICBsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gICAgbGV0IHByZWNpc2lvbiA9IGluZGV4ID49IDAgPyBzdHJpbmcubGVuZ3RoIC0gaW5kZXggOiAwO1xuICAgIGlmIChwcmVjaXNpb24gPiAwKSB7XG4gICAgICAgIGxldCBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgc25hcHBlZFZhbHVlID0gTWF0aC5yb3VuZChzbmFwcGVkVmFsdWUgKiBwb3cpIC8gcG93O1xuICAgIH1cbiAgICByZXR1cm4gc25hcHBlZFZhbHVlO1xufVxuZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZih2YWx1ZSwgZGlnaXRzLCBiYXNlID0gMTApIHtcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdyhiYXNlLCBkaWdpdHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcG93KSAvIHBvdztcbn1cblxuXG5cblxuZXhwb3J0IHskNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSBhcyB1c2VDb250cm9sbGVkU3RhdGUsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0IGFzIGNsYW1wLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2MyBhcyBzbmFwVmFsdWVUb1N0ZXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYgYXMgdG9GaXhlZE51bWJlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n// use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf = typeof window !== \"undefined\" ? window.performance : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\n\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n        this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) // @ts-ignore\n            this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (// Uses equals rather than pointEquals so that width/height changes are taken into account\n            !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// If an item has a width of 0, there is no need to remove it from the _visibleViews.\n        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\n\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQsMkNBQTJDO0FBQzNDLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0Isd0JBQXdCLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQixhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixlQUFlLHVEQUF1RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUpBQWlKO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QywyQ0FBZTtBQUM3RCw0Q0FBNEMsMkNBQWU7QUFDM0QsMENBQTBDLDJDQUFlO0FBQ3pELDBDQUEwQywyQ0FBZTtBQUN6RCwwQkFBMEIsMENBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQXNCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsOENBQWtCO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsOENBQWtCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBa0I7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNFk7QUFDNVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzPzBhZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkOEQzbnIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDhEM25yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkOEQzbnIkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkOEQzbnIkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJDhEM25yJHVzZUxheW91dEVmZmVjdH0gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBpbnZhbGlkYXRlIGluIHJlc3BvbnNlIHRvXG4gICAqIHZpc2libGUgcmVjdGFuZ2xlIGNoYW5nZXMuIEJ5IGRlZmF1bHQsIGl0IG9ubHkgaW52YWxpZGF0ZXNcbiAgICogd2hlbiB0aGUgY29sbGVjdGlvbiB2aWV3J3Mgc2l6ZSBjaGFuZ2VzLiBSZXR1cm4gdHJ1ZSBhbHdheXNcbiAgICogdG8gbWFrZSB0aGUgbGF5b3V0IGludmFsaWRhdGUgd2hpbGUgc2Nyb2xsaW5nIChlLmcuIHN0aWNreSBoZWFkZXJzKS5cbiAgICovIHNob3VsZEludmFsaWRhdGUobmV3UmVjdCwgb2xkUmVjdCkge1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCBpbnZhbGlkYXRlIHdoZW4gdGhlIHNpemUgY2hhbmdlc1xuICAgICAgICByZXR1cm4gbmV3UmVjdC53aWR0aCAhPT0gb2xkUmVjdC53aWR0aCB8fCBuZXdSZWN0LmhlaWdodCAhPT0gb2xkUmVjdC5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgdGhlIGxheW91dCB0byBwZXJmb3JtIGFueSBwcmUtY29tcHV0YXRpb25cbiAgICogaXQgbmVlZHMgdG8gaW4gb3JkZXIgdG8gcHJlcGFyZSB7QGxpbmsgTGF5b3V0SW5mb31zIGZvciByZXRyaWV2YWwuXG4gICAqIENhbGxlZCBieSB0aGUgY29sbGVjdGlvbiB2aWV3IGJlZm9yZSB7QGxpbmsgZ2V0VmlzaWJsZUxheW91dEluZm9zfVxuICAgKiBvciB7QGxpbmsgZ2V0TGF5b3V0SW5mb30gYXJlIGNhbGxlZC5cbiAgICovIHZhbGlkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHt9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgRHJhZ1RhcmdldH0gZGVzY3JpYmluZyBhIHZpZXcgYXQgdGhlIGdpdmVuIHBvaW50IHRvIGJlIGRyYWdnZWQuXG4gICAqIFJldHVybiBgbnVsbGAgdG8gY2FuY2VsIHRoZSBkcmFnLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRoZSB2aWV3IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCBhdCB3aGljaCB0aGUgZHJhZyBvY2N1cnJlZC5cbiAgICovIC8vIGdldERyYWdUYXJnZXQocG9pbnQ6IFBvaW50KTogRHJhZ1RhcmdldCB8IG51bGwge1xuICAgIC8vICAgbGV0IHRhcmdldCA9IHRoaXMudmlydHVhbGl6ZXIua2V5QXRQb2ludChwb2ludCk7XG4gICAgLy8gICBpZiAoIXRhcmdldCkge1xuICAgIC8vICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiB7XG4gICAgLy8gICAgIHR5cGU6ICdpdGVtJyxcbiAgICAvLyAgICAga2V5OiB0YXJnZXRcbiAgICAvLyAgIH07XG4gICAgLy8gfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIERyYWdUYXJnZXR9IG9iamVjdCBkZXNjcmliaW5nIHdoZXJlIGEgZHJvcCBzaG91bGQgb2NjdXIuIFJldHVybiBgbnVsbGBcbiAgICogdG8gcmVqZWN0IHRoZSBkcm9wLiBUaGUgZHJvcHBlZCBpdGVtcyB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgcmVzdWx0aW5nIHRhcmdldC5cbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCBhdCB3aGljaCB0aGUgZHJvcCBvY2N1cnJlZC5cbiAgICovIC8vIGdldERyb3BUYXJnZXQocG9pbnQ6IFBvaW50KTogRHJvcFRhcmdldCB8IG51bGwge1xuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBhdHRyaWJ1dGVzIGZvciBhbiBhbmltYXRlZCBpbnNlcnRpb24uXG4gICAqIFRoZSB2aWV3IGlzIGFuaW1hdGVkIGZyb20gdGhpcyB7QGxpbmsgTGF5b3V0SW5mb30gdG8gdGhlIG9uZSByZXR1cm5lZCBieSB7QGxpbmsgZ2V0TGF5b3V0SW5mb30uXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBpdHMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSBsYXlvdXRJbmZvIFRoZSBwcm9wb3NlZCBMYXlvdXRJbmZvIGZvciB0aGlzIHZpZXcuXG4gICAqLyBnZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kaW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIHJlbW92YWwuXG4gICAqIFRoZSB2aWV3IGlzIGFuaW1hdGVkIGZyb20gdGhlIHtAbGluayBMYXlvdXRJbmZvfSByZXR1cm5lZCBieSB7QGxpbmsgZ2V0TGF5b3V0SW5mb31cbiAgICogdG8gdGhlIG9uZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBpdHMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSBsYXlvdXRJbmZvIFRoZSBvcmlnaW5hbCBMYXlvdXRJbmZvIGZvciB0aGlzIHZpZXcuXG4gICAqLyBnZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mbykge1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIExheW91dEluZm8uXG4gICAqLyBjb3B5KCkge1xuICAgICAgICBsZXQgcmVzID0gbmV3ICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1KHRoaXMudHlwZSwgdGhpcy5rZXksIHRoaXMucmVjdC5jb3B5KCkpO1xuICAgICAgICByZXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgcmVzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIHJlcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgcmVzLnBhcmVudEtleSA9IHRoaXMucGFyZW50S2V5O1xuICAgICAgICByZXMuaXNTdGlja3kgPSB0aGlzLmlzU3RpY2t5O1xuICAgICAgICByZXMuekluZGV4ID0gdGhpcy56SW5kZXg7XG4gICAgICAgIHJlcy5hbGxvd092ZXJmbG93ID0gdGhpcy5hbGxvd092ZXJmbG93O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICogQHBhcmFtIHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2aWV3IHR5cGUuIFNob3VsZCBiZSBgJ2l0ZW0nYCBmb3IgaXRlbSB2aWV3cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdGhlciB0eXBlcyBhcmUgdXNlZCBieSBzdXBwbGVtZW50YXJ5IHZpZXdzLlxuICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IGZvciB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSByZWN0IFRoZSByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhpcyB2aWV3LlxuICAgKi8gY29uc3RydWN0b3IodHlwZSwga2V5LCByZWN0KXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGFyZW50S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWN0ID0gcmVjdDtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGlja3kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYWxsb3dPdmVyZmxvdyA9IGZhbHNlO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvaW50LlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWwuXG4gICAqLyBlcXVhbHMocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyB0aGUgb3JpZ2luLlxuICAgKi8gaXNPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCB7XG4gICAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHgtY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IG1heFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIG1heGltdW0geS1jb29yZGluYXRlIGluIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgbWF4WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGFyZWEgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHRvcExlZnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHRvcFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy5tYXhYLCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGJvdHRvbUxlZnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLngsIHRoaXMubWF4WSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGJvdHRvbVJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy5tYXhYLCB0aGlzLm1heFkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmVjdGFuZ2xlIGludGVyc2VjdHMgYW5vdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGludGVyc2VjdHMocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgdGhpcy55IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0ICYmIHJlY3QueSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHJlY3RhbmdsZSBmdWxseSBjb250YWlucyBhbm90aGVyIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gY29udGFpbnNSZWN0KHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByZWN0LnggJiYgdGhpcy55IDw9IHJlY3QueSAmJiB0aGlzLm1heFggPj0gcmVjdC5tYXhYICYmIHRoaXMubWF4WSA+PSByZWN0Lm1heFk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVjay5cbiAgICovIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSBwb2ludC54ICYmIHRoaXMueSA8PSBwb2ludC55ICYmIHRoaXMubWF4WCA+PSBwb2ludC54ICYmIHRoaXMubWF4WSA+PSBwb2ludC55O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgY29ybmVyIG9mIHRoaXMgcmVjdGFuZ2xlIChmcm9tIHRvcCB0byBib3R0b20sIGxlZnQgdG8gcmlnaHQpXG4gICAqIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiByZWN0YW5nbGUsIG9yIG51bGwgb2YgdGhlIHJlY3RhbmdsZXMgZG8gbm90IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gZ2V0Q29ybmVySW5SZWN0KHJlY3QpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIFtcbiAgICAgICAgICAgIFwidG9wTGVmdFwiLFxuICAgICAgICAgICAgXCJ0b3BSaWdodFwiLFxuICAgICAgICAgICAgXCJib3R0b21MZWZ0XCIsXG4gICAgICAgICAgICBcImJvdHRvbVJpZ2h0XCJcbiAgICAgICAgXSl7XG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNba2V5XSkpIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVxdWFscyhyZWN0KSB7XG4gICAgICAgIHJldHVybiByZWN0LnggPT09IHRoaXMueCAmJiByZWN0LnkgPT09IHRoaXMueSAmJiByZWN0LndpZHRoID09PSB0aGlzLndpZHRoICYmIHJlY3QuaGVpZ2h0ID09PSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRFcXVhbHMocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgfVxuICAgIHNpemVFcXVhbHMoc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGlzIFJlY3QgYW5kIGFub3RoZXIuXG4gICAqLyB1bmlvbihvdGhlcikge1xuICAgICAgICBsZXQgeCA9IE1hdGgubWluKHRoaXMueCwgb3RoZXIueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5taW4odGhpcy55LCBvdGhlci55KTtcbiAgICAgICAgbGV0IHdpZHRoID0gTWF0aC5tYXgodGhpcy5tYXhYLCBvdGhlci5tYXhYKSAtIHg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1heFksIG90aGVyLm1heFkpIC0geTtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIFJlY3Qgd2l0aCBhbm90aGVyLlxuICAgKiBJZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LCBhbiBhbGwgemVybyBSZWN0IGlzIHJldHVybmVkLlxuICAgKi8gaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcnNlY3RzKG90aGVyKSkgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCgwLCAwLCAwLCAwKTtcbiAgICAgICAgbGV0IHggPSBNYXRoLm1heCh0aGlzLngsIG90aGVyLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGgubWF4KHRoaXMueSwgb3RoZXIueSk7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoeCwgeSwgTWF0aC5taW4odGhpcy5tYXhYLCBvdGhlci5tYXhYKSAtIHgsIE1hdGgubWluKHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCl7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2l6ZS5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgc2l6ZSBpcyBlcXVhbCB0byBhbm90aGVyIG9uZS5cbiAgICovIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3RhbCBhcmVhIG9mIHRoZSBTaXplLlxuICAgKi8gZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCl7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBsZXQgJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWSA9IDA7XG5jbGFzcyAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSB7XG4gICAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSB2aWV3IGZvciByZXVzZS4gQ2FsbGVkIGp1c3QgYmVmb3JlIHRoZSB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi8gcHJlcGFyZUZvclJldXNlKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXlvdXRJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmlydHVhbGl6ZXIpe1xuICAgICAgICB0aGlzLnZpcnR1YWxpemVyID0gdmlydHVhbGl6ZXI7XG4gICAgICAgIHRoaXMua2V5ID0gKyskYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIHVzZSBoaWdoIHJlcyB0aW1lciBpZiBhdmFpbGFibGVcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cucGVyZm9ybWFuY2UgOiBudWxsO1xuLy8gQHRzLWlnbm9yZVxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYgJiYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi53ZWJraXROb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubXNOb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubW96Tm93KTtcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93ID8gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cuYmluZCgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZikgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcztcbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKGJlZ2luLCBlbmQsIGR1cmF0aW9uLCBlYXNlLCBmbikge1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByYWZfaWQ7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgbGV0IHN0YXJ0ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKTtcbiAgICAgICAgbGV0IGRpZmZYID0gZW5kLnggLSBiZWdpbi54O1xuICAgICAgICBsZXQgZGlmZlkgPSBlbmQueSAtIGJlZ2luLnk7XG4gICAgICAgIHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBydW4odCkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgdXNpbmcgYSBoaWdoIHJlcyB0aW1lciwgbWFrZSBzdXJlIHRpbWVzdGFtcCBpcyBub3QgdGhlIG9sZCBlcG9jaC1iYXNlZCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXG4gICAgICAgICAgICBpZiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID09IG51bGwpICQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyA9IHQgPiAxZTEyICE9PSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpID4gMWUxMjtcbiAgICAgICAgICAgIGlmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMpIHQgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UncmUgZG9uZVxuICAgICAgICAgICAgbGV0IGRlbHRhID0gdCAtIHN0YXJ0O1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmbihlbmQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBmcmFtZSBjYWxsYmFjayBhZnRlciBjb21wdXRpbmcgZWFzZWQgdGltZSBhbmQgZ2V0IHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICAgICAgbGV0IHByb2NlZWQgPSBmbihuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKShiZWdpbi54ICsgZGlmZlggKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pLCBiZWdpbi55ICsgZGlmZlkgKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2NlZWQgIT09IGZhbHNlICYmICFjYW5jZWxlZCkgcmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmX2lkKTtcbiAgICB9O1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDc3ODYwYzEwNmI0YTZhMmUodCkge1xuICAgIHJldHVybiB0O1xufVxuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjAodCkge1xuICAgIHJldHVybiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShhLCBiKSB7XG4gICAgbGV0IHJlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKCkpaWYgKCFiLmhhcyhrZXkpKSByZXMuYWRkKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiKGEsIGIpIHtcbiAgICBsZXQgdG9SZW1vdmUgPSAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShhLCBiKTtcbiAgICBsZXQgdG9BZGQgPSAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShiLCBhKTtcbiAgICBsZXQgdG9VcGRhdGUgPSBuZXcgU2V0O1xuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoYi5oYXMoa2V5KSkgdG9VcGRhdGUuYWRkKGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9SZW1vdmU6IHRvUmVtb3ZlLFxuICAgICAgICB0b0FkZDogdG9BZGQsXG4gICAgICAgIHRvVXBkYXRlOiB0b1VwZGF0ZVxuICAgIH07XG59XG5mdW5jdGlvbiogJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYoLi4uaXRlcmF0b3JzKSB7XG4gICAgZm9yIChsZXQgaXRlcmF0b3Igb2YgaXRlcmF0b3JzKXlpZWxkKiBpdGVyYXRvcjtcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQ2ODk3YzI4NGI2ZjlmNGRjKG9iamVjdCkge1xuICAgIGxldCByZXMgPSB7fTtcbiAgICBmb3IobGV0IGtleSBpbiBvYmplY3QpcmVzW29iamVjdFtrZXldXSA9IGtleTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYSl7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNsYXNzICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSB7XG4gICAgYWRkU2FtcGxlKHNhbXBsZSkge1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIHRoaXMudmFsdWUgKz0gKHNhbXBsZSAtIHRoaXMudmFsdWUpIC8gdGhpcy5jb3VudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIH1cbn1cbmNsYXNzICQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiIHtcbiAgICBzZXRWaXNpYmxlUmVjdChyZWN0KSB7XG4gICAgICAgIGxldCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuYXZlcmFnZVRpbWUuYWRkU2FtcGxlKHRpbWUpO1xuICAgICAgICAgICAgaWYgKHJlY3QueCAhPT0gdGhpcy52aXNpYmxlUmVjdC54ICYmIHRpbWUgPiAwKSB0aGlzLnZlbG9jaXR5LnggPSAocmVjdC54IC0gdGhpcy52aXNpYmxlUmVjdC54KSAvIHRpbWU7XG4gICAgICAgICAgICBpZiAocmVjdC55ICE9PSB0aGlzLnZpc2libGVSZWN0LnkgJiYgdGltZSA+IDApIHRoaXMudmVsb2NpdHkueSA9IChyZWN0LnkgLSB0aGlzLnZpc2libGVSZWN0LnkpIC8gdGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgY29sbGVjdE1ldHJpY3MoKSB7XG4gICAgICAgIGxldCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWUgPCA1MDApIHRoaXMuYXZlcmFnZVBlcmYuYWRkU2FtcGxlKHRpbWUpO1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbyA9IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueSAqICh0aGlzLmF2ZXJhZ2VUaW1lLnZhbHVlICsgdGhpcy5hdmVyYWdlUGVyZi52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVyc2NhblkuYWRkU2FtcGxlKG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVSZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgbGV0IG8gPSBNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnggKiAodGhpcy5hdmVyYWdlVGltZS52YWx1ZSArIHRoaXMuYXZlcmFnZVBlcmYudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5YLmFkZFNhbXBsZShvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPdmVyc2Nhbm5lZFJlY3QoKSB7XG4gICAgICAgIGxldCBvdmVyc2Nhbm5lZCA9IHRoaXMudmlzaWJsZVJlY3QuY29weSgpO1xuICAgICAgICBsZXQgb3ZlcnNjYW5ZID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LmhlaWdodCAqIDIsIHRoaXMub3ZlcnNjYW5ZLnZhbHVlKSAvIDEwMCkgKiAxMDA7XG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnkgPiAwKSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC55IC09IG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLmhlaWdodCArPSBvdmVyc2NhblkgKyBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC55IC09IG92ZXJzY2FuWTtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLmhlaWdodCArPSBvdmVyc2NhblkgKyBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJzY2FuWCA9IE1hdGgucm91bmQoTWF0aC5taW4odGhpcy52aXNpYmxlUmVjdC53aWR0aCAqIDIsIHRoaXMub3ZlcnNjYW5YLnZhbHVlKSAvIDEwMCkgKiAxMDA7XG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnggPiAwKSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC54IC09IG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLndpZHRoICs9IG92ZXJzY2FuWCArIG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyc2Nhbm5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VQZXJmID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VUaW1lID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoNSwgNSk7XG4gICAgICAgIHRoaXMub3ZlcnNjYW5YID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLm92ZXJzY2FuWSA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKCk7XG4gICAgfVxufVxuXG5cblxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmluaXRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbExheW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmluYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudG9SZW1vdmUgPSBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5cbmNsYXNzICQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyIHtcbiAgICBfc2V0Q29udGVudFNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0Q29udGVudFNpemUoc2l6ZSk7XG4gICAgfVxuICAgIF9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKG9mZnNldC54LCBvZmZzZXQueSwgdGhpcy5fdmlzaWJsZVJlY3Qud2lkdGgsIHRoaXMuX3Zpc2libGVSZWN0LmhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgY29udGVudC5cbiAgICovIGdldCBjb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBjdXJyZW50bHkgdmlzaWJsZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdmlzaWJsZVJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgY3VycmVudGx5IHZpc2libGUgcmVjdGFuZ2xlLlxuICAgKi8gc2V0IHZpc2libGVSZWN0KHJlY3QpIHtcbiAgICAgICAgdGhpcy5fc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgfVxuICAgIF9zZXRWaXNpYmxlUmVjdChyZWN0LCBmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdmlzaWJsZVJlY3Q7XG4gICAgICAgIC8vIElnbm9yZSBpZiB0aGUgcmVjdHMgYXJlIGVxdWFsXG4gICAgICAgIGlmIChyZWN0LmVxdWFscyhjdXJyZW50KSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRPdmVyc2NhbikgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLnNldFZpc2libGVSZWN0KHJlY3QpO1xuICAgICAgICBsZXQgc2hvdWxkSW52YWxpZGF0ZSA9IHRoaXMubGF5b3V0ICYmIHRoaXMubGF5b3V0LnNob3VsZEludmFsaWRhdGUocmVjdCwgdGhpcy5fdmlzaWJsZVJlY3QpO1xuICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSAvLyBXZSBhcmUgYWxyZWFkeSBpbiBhIGxheW91dCBlZmZlY3Qgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHNvIHJlbGF5b3V0Tm93IGlzIGFwcHJvcHJpYXRlLlxuICAgICAgICB0aGlzLnJlbGF5b3V0Tm93KHtcbiAgICAgICAgICAgIG9mZnNldENoYW5nZWQ6ICFyZWN0LnBvaW50RXF1YWxzKGN1cnJlbnQpLFxuICAgICAgICAgICAgc2l6ZUNoYW5nZWQ6ICFyZWN0LnNpemVFcXVhbHMoY3VycmVudClcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgdGhpcy51cGRhdGVTdWJ2aWV3cyhmb3JjZVVwZGF0ZSk7XG4gICAgfVxuICAgIGdldCBjb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB9XG4gICAgc2V0IGNvbGxlY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLl9zZXREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB0aGlzLl9jb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB0aGlzLl9ydW5UcmFuc2FjdGlvbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGRhdGE7XG4gICAgICAgIH0sIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uID4gMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZERhdGEoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogUmVsb2FkcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBhbmQgcmVsYXlvdXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAqIERvZXMgbm90IGFuaW1hdGUgYW55IGNoYW5nZXMuIEVxdWl2YWxlbnQgdG8gcmUtYXNzaWduaW5nIHRoZSBzYW1lIGRhdGEgc291cmNlXG4gICAqIHRvIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAqLyByZWxvYWREYXRhKCkge1xuICAgICAgICB0aGlzLnJlbGF5b3V0KHtcbiAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2VkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gICAqLyBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbiA/IHRoaXMuX2NvbGxlY3Rpb24uZ2V0SXRlbShrZXkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBnZXQgcGVyc2lzdGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcnNpc3RlZEtleXM7XG4gICAgfVxuICAgIC8qKiBUaGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzIGFyZSBhbHdheXMgcHJlc2VudCBpbiB0aGUgRE9NLCBldmVuIGlmIG5vdCBjdXJyZW50bHkgaW4gdmlldy4gKi8gc2V0IHBlcnNpc3RlZEtleXMocGVyc2lzdGVkS2V5cykge1xuICAgICAgICBpZiAoISgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NCkocGVyc2lzdGVkS2V5cywgdGhpcy5fcGVyc2lzdGVkS2V5cykpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBwZXJzaXN0ZWRLZXlzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJ2aWV3cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGtleSwgb3IgYW4gYW5jZXN0b3IsIGlzIHBlcnNpc3RlZC4gKi8gaXNQZXJzaXN0ZWRLZXkoa2V5KSB7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIGlmIHRoZSBrZXkgaXMgZGlyZWN0bHkgaW4gdGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cy5cbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlZEtleXMuaGFzKGtleSkpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiBub3QsIGNoZWNrIGlmIHRoZSBrZXkgaXMgYW4gYW5jZXN0b3Igb2YgYW55IG9mIHRoZSBwZXJzaXN0ZWQga2V5cy5cbiAgICAgICAgZm9yIChsZXQgayBvZiB0aGlzLl9wZXJzaXN0ZWRLZXlzKXdoaWxlKGsgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oayk7XG4gICAgICAgICAgICBpZiAoIWxheW91dEluZm8pIGJyZWFrO1xuICAgICAgICAgICAgayA9IGxheW91dEluZm8ucGFyZW50S2V5O1xuICAgICAgICAgICAgaWYgKGsgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQuXG4gICAqLyBnZXQgbGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQuXG4gICAqLyBzZXQgbGF5b3V0KGxheW91dCkge1xuICAgICAgICB0aGlzLnNldExheW91dChsYXlvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LCBvcHRpb25hbGx5IHdpdGggYW4gYW5pbWF0ZWQgdHJhbnNpdGlvblxuICAgKiBmcm9tIHRoZSBjdXJyZW50IGxheW91dCB0byB0aGUgbmV3IGxheW91dC5cbiAgICogQHBhcmFtIGxheW91dCBUaGUgbGF5b3V0IHRvIHN3aXRjaCB0by5cbiAgICogQHBhcmFtIGFuaW1hdGVkIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgbGF5b3V0IGNoYW5nZS5cbiAgICovIHNldExheW91dChsYXlvdXQsIGFuaW1hdGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gdGhpcy5fbGF5b3V0KSByZXR1cm47XG4gICAgICAgIGxldCBhcHBseUxheW91dCA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5b3V0KSAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQudmlydHVhbGl6ZXIgPSBudWxsO1xuICAgICAgICAgICAgbGF5b3V0LnZpcnR1YWxpemVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFuaW1hdGVkKSAvLyBBbmltYXRlZCBsYXlvdXQgdHJhbnNpdGlvbnMgYXJlIHJlYWxseSBzaW1wbGUsIHRoYW5rcyB0byBvdXIgdHJhbnNhY3Rpb24gc3VwcG9ydC5cbiAgICAgICAgLy8gV2UganVzdCBzZXQgdGhlIGxheW91dCBpbnNpZGUgYSB0cmFuc2FjdGlvbiBhY3Rpb24sIHdoaWNoIHJ1bnMgYWZ0ZXIgdGhlIGluaXRpYWxcbiAgICAgICAgLy8gbGF5b3V0IGluZm9zIGZvciB0aGUgYW5pbWF0aW9uIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgcHJldmlvdXMgbGF5b3V0LiBUaGVuLCB0aGVcbiAgICAgICAgLy8gZmluYWwgbGF5b3V0IGluZm9zIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgbmV3IGxheW91dCwgYW5kIGFuaW1hdGlvbnMgb2NjdXIuXG4gICAgICAgIHRoaXMuX3J1blRyYW5zYWN0aW9uKGFwcGx5TGF5b3V0KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcHBseUxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRSZXVzZVR5cGUobGF5b3V0SW5mbywgY29udGVudCkge1xuICAgICAgICBpZiAobGF5b3V0SW5mby50eXBlID09PSBcIml0ZW1cIiAmJiBjb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZSA/IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZShjb250ZW50KSA6IFwiaXRlbVwiO1xuICAgICAgICAgICAgbGV0IHJldXNlVHlwZSA9IHR5cGUgPT09IFwiaXRlbVwiID8gXCJpdGVtXCIgOiBsYXlvdXRJbmZvLnR5cGUgKyBcIl9cIiArIHR5cGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcmV1c2VUeXBlOiByZXVzZVR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGxheW91dEluZm8udHlwZSxcbiAgICAgICAgICAgIHJldXNlVHlwZTogbGF5b3V0SW5mby50eXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5nZXRJdGVtKGxheW91dEluZm8ua2V5KTtcbiAgICAgICAgbGV0IHsgcmV1c2VUeXBlOiByZXVzZVR5cGUgfSA9IHRoaXMuX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV0pIHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSA9IFtdO1xuICAgICAgICBsZXQgcmV1c2FibGUgPSB0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV07XG4gICAgICAgIGxldCB2aWV3ID0gcmV1c2FibGUubGVuZ3RoID4gMCA/IHJldXNhYmxlLnBvcCgpIDogbmV3ICgwLCAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSkodGhpcyk7XG4gICAgICAgIHZpZXcudmlld1R5cGUgPSByZXVzZVR5cGU7XG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgIGxheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIGxheW91dEluZm8ucmVjdC54ICs9IHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xuICAgICAgICAgICAgbGF5b3V0SW5mby5yZWN0LnkgKz0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICAgICAgdGhpcy5fcmVuZGVyVmlldyh2aWV3KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIF9yZW5kZXJWaWV3KHJldXNhYmxlVmlldykge1xuICAgICAgICBsZXQgeyB0eXBlOiB0eXBlLCBrZXk6IGtleSB9ID0gcmV1c2FibGVWaWV3LmxheW91dEluZm87XG4gICAgICAgIHJldXNhYmxlVmlldy5jb250ZW50ID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIHJldXNhYmxlVmlldy5yZW5kZXJlZCA9IHRoaXMuX3JlbmRlckNvbnRlbnQodHlwZSwgcmV1c2FibGVWaWV3LmNvbnRlbnQpO1xuICAgIH1cbiAgICBfcmVuZGVyQ29udGVudCh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yZW5kZXJlZENvbnRlbnQuZ2V0KGNvbnRlbnQpO1xuICAgICAgICBpZiAoY2FjaGVkICE9IG51bGwpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCByZW5kZXJlZCA9IHRoaXMuZGVsZWdhdGUucmVuZGVyVmlldyh0eXBlLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHRoaXMuX3JlbmRlcmVkQ29udGVudC5zZXQoY29udGVudCwgcmVuZGVyZWQpO1xuICAgICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBjdXJyZW50bHkgdmlzaWJsZSB2aWV3cywgaW5jbHVkaW5nIGJvdGhcbiAgICogaXRlbSB2aWV3cyBhbmQgc3VwcGxlbWVudGFyeSB2aWV3cy5cbiAgICovIGdldCB2aXNpYmxlVmlld3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSB2aXNpYmxlIHZpZXcgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBrZXkuIFJldHVybnMgbnVsbCBpZlxuICAgKiB0aGUgdmlldyBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdmlldyB0byByZXRyaWV2ZS5cbiAgICovIGdldFZpZXcoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmlzaWJsZSB2aWV3cyBtYXRjaGluZyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHZpZXcgdHlwZSB0byBmaW5kLlxuICAgKi8gZ2V0Vmlld3NPZlR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlVmlld3MuZmlsdGVyKCh2KT0+di5sYXlvdXRJbmZvICYmIHYubGF5b3V0SW5mby50eXBlID09PSB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIGdpdmVuIHZpZXcuIFJldHVybnMgbnVsbFxuICAgKiBpZiB0aGUgdmlldyBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXG4gICAqLyBrZXlGb3JWaWV3KHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5sYXlvdXRJbmZvKSByZXR1cm4gdmlldy5sYXlvdXRJbmZvLmtleTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBpdGVtIHZpZXcgY3VycmVudGx5IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICovIGtleUF0UG9pbnQocG9pbnQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKShwb2ludC54LCBwb2ludC55LCAxLCAxKTtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICAvLyBMYXlvdXQgbWF5IHJldHVybiBtdWx0aXBsZSBsYXlvdXQgaW5mb3MgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgICAgLy8gcGVyc2lzdGVkIGtleXMsIHNvIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGFjdHVhbGx5IGludGVyc2VjdHMuXG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpKSByZXR1cm4gbGF5b3V0SW5mby5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDbGVhbnVwIGZvciB3aGVuIHRoZSBWaXJ0dWFsaXplciB3aWxsIGJlIHVubW91bnRlZC5cbiAgICovIHdpbGxVbm1vdW50KCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZWxheW91dFJhZik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUcmlnZ2VycyBhIGxheW91dCBpbnZhbGlkYXRpb24sIGFuZCB1cGRhdGVzIHRoZSB2aXNpYmxlIHN1YnZpZXdzLlxuICAgKi8gcmVsYXlvdXQoY29udGV4dCA9IHt9KSB7XG4gICAgICAgIC8vIElnbm9yZSByZWxheW91dHMgd2hpbGUgYW5pbWF0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbiB8fCB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgc2NoZWR1bGVkIGEgcmVsYXlvdXQsIGV4dGVuZCB0aGUgaW52YWxpZGF0aW9uXG4gICAgICAgIC8vIGNvbnRleHQgc28gd2UgY29hbGVzY2UgbXVsdGlwbGUgcmVsYXlvdXRzIGluIHRoZSBzYW1lIGZyYW1lLlxuICAgICAgICBpZiAodGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgcmVsYXlvdXQgaW1tZWRpYXRlbHkuIFByZWZlciB7QGxpbmsgcmVsYXlvdXR9IG92ZXIgdGhpcyBtZXRob2RcbiAgICogd2hlcmUgcG9zc2libGUsIHNpbmNlIGl0IGNvYWxlc2NlcyBtdWx0aXBsZSBsYXlvdXQgcGFzc2VzIGluIHRoZSBzYW1lIHRpY2suXG4gICAqLyByZWxheW91dE5vdyhjb250ZXh0ID0gdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCB8fCB7fSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIHNjaGVkdWxlZCByZWxheW91dCwgc2luY2Ugd2UncmUgZG9pbmcgaXQgbm93LlxuICAgICAgICBpZiAodGhpcy5fcmVsYXlvdXRSYWYpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF5b3V0UmFmID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvdmlkZWQgY29udGV4dCB3aXRoIHRoZSBjdXJyZW50IGludmFsaWRhdGlvbkNvbnRleHQgc2luY2Ugd2UgYXJlIGNhbmNlbGxpbmdcbiAgICAgICAgICAgIC8vIGEgc2NoZWR1bGVkIHJlbGF5b3V0Tm93IGNhbGwgdGhhdCBoYXMgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCBzZXQgYXMgaXRzIGRlZmF1bHQgY29udGV4dCBhcmcgKHJlbGF5b3V0Tm93KCkgaW4gcmVsYXlvdXQpXG4gICAgICAgICAgICBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uY29udGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgaW52YWxpZGF0aW9uIGNvbnRleHRcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UgZG9uJ3QgaGF2ZSBhIGxheW91dCBvciBjb250ZW50LCBvciB3ZSBhcmVcbiAgICAgICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhbiBhbmltYXRlZCBzY3JvbGwgdHJhbnNpdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhdGhpcy5fY29sbGVjdGlvbiB8fCB0aGlzLl9zY3JvbGxBbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IHNjcm9sbEFuY2hvciA9IHRoaXMuX2dldFNjcm9sbEFuY2hvcigpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBiZWZvcmVMYXlvdXQgaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmJlZm9yZUxheW91dCA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmJlZm9yZUxheW91dCgpO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgbGF5b3V0XG4gICAgICAgIHRoaXMubGF5b3V0LnZhbGlkYXRlKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50U2l6ZSh0aGlzLmxheW91dC5nZXRDb250ZW50U2l6ZSgpKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgYWZ0ZXJMYXlvdXQgaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyTGF5b3V0ID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJMYXlvdXQoKTtcbiAgICAgICAgLy8gQWRqdXN0IHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiBzY3JvbGwgYW5jaG9yLCBhbmQgY29uc3RyYWluLlxuICAgICAgICAvLyBJZiB0aGUgY29udGVudCBjaGFuZ2VkLCBzY3JvbGwgdG8gdGhlIHRvcC5cbiAgICAgICAgbGV0IHZpc2libGVSZWN0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICBsZXQgcmVzdG9yZWRTY3JvbGxBbmNob3IgPSB0aGlzLl9yZXN0b3JlU2Nyb2xsQW5jaG9yKHNjcm9sbEFuY2hvciwgY29udGV4dCk7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0WCA9IGNvbnRleHQuY29udGVudENoYW5nZWQgPyAwIDogcmVzdG9yZWRTY3JvbGxBbmNob3IueDtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXRZID0gY29udGV4dC5jb250ZW50Q2hhbmdlZCA/IDAgOiByZXN0b3JlZFNjcm9sbEFuY2hvci55O1xuICAgICAgICBjb250ZW50T2Zmc2V0WCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuY29udGVudFNpemUud2lkdGggLSB2aXNpYmxlUmVjdC53aWR0aCwgY29udGVudE9mZnNldFgpKTtcbiAgICAgICAgY29udGVudE9mZnNldFkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmhlaWdodCwgY29udGVudE9mZnNldFkpKTtcbiAgICAgICAgbGV0IGhhc0xheW91dFVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbnRlbnRPZmZzZXRYICE9PSB2aXNpYmxlUmVjdC54IHx8IGNvbnRlbnRPZmZzZXRZICE9PSB2aXNpYmxlUmVjdC55KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFuaW1hdGVkIHJlbGF5b3V0LCB3ZSBkbyBub3QgaW1tZWRpYXRlbHkgc2Nyb2xsIGJlY2F1c2UgaXQgd291bGQgYmUgaml0dGVyeS5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgbmV3IGNvbnRlbnQgb2Zmc2V0cywgYW5kIGFwcGx5IGl0IHRvIHRoZVxuICAgICAgICAgICAgLy8gaW5kaXZpZHVhbCBjb250ZW50IGl0ZW1zIGluc3RlYWQuIEF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbiwgd2UnbGwgcmVzZXQgYW5kIHNldCB0aGVcbiAgICAgICAgICAgIC8vIHNjcm9sbCBvZmZzZXQgZm9yIHJlYWwuIFRoaXMgZW5zdXJlcyBqaXR0ZXItZnJlZSBhbmltYXRpb24gc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBzeW5jXG4gICAgICAgICAgICAvLyB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBhbmQgdGhlIGNvbnRlbnQgYW5pbWF0aW9uLlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuYW5pbWF0ZWQgfHwgIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnggKz0gdmlzaWJsZVJlY3QueCAtIGNvbnRlbnRPZmZzZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55ICs9IHZpc2libGVSZWN0LnkgLSBjb250ZW50T2Zmc2V0WTtcbiAgICAgICAgICAgICAgICBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGNvbnRlbnRPZmZzZXRYLCBjb250ZW50T2Zmc2V0WSkpO1xuICAgICAgICB9IGVsc2UgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMudXBkYXRlU3Vidmlld3MoY29udGV4dC5jb250ZW50Q2hhbmdlZCk7XG4gICAgICAgIC8vIEFwcGx5IGxheW91dCBpbmZvcywgdW5sZXNzIHRoaXMgaXMgY29taW5nIGZyb20gYW4gYW5pbWF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKCEoY29udGV4dC50cmFuc2FjdGlvbiAmJiBjb250ZXh0LmFuaW1hdGVkKSkgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICAvLyBXYWl0IGZvciBhbmltYXRpb25zLCBhbmQgYXBwbHkgdGhlIGFmdGVyQW5pbWF0aW9uIGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChjb250ZXh0LmFuaW1hdGVkICYmIGhhc0xheW91dFVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRyYW5zaXRpb25zKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9ICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVRyYW5zaXRpb25zKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGFuaW1hdGlvbnMgKHNlZSBhYm92ZSBjb21tZW50KS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY29udGVudCBvZmZzZXQgdG8gc2Nyb2xsIHRvLCB0YWtpbmcgX2FuaW1hdGVkQ29udGVudE9mZnNldCBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHg6IHgsIHk6IHkgfSA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh4LCB5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckFuaW1hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBhbmltYXRpb24gdGFrZXMgc2xpZ2h0bHkgbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uICsgMTAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckFuaW1hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDb3JyZWN0cyBET00gb3JkZXIgb2YgdmlzaWJsZSB2aWV3cyB0byBtYXRjaCBpdGVtIG9yZGVyIG9mIGNvbGxlY3Rpb24uXG4gICAqLyBfY29ycmVjdEl0ZW1PcmRlcigpIHtcbiAgICAgICAgLy8gRGVmZXIgdW50aWwgYWZ0ZXIgc2Nyb2xsaW5nIGFuZCBhbmltYXRlZCB0cmFuc2FjdGlvbnMgYXJlIGNvbXBsZXRlXG4gICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCB0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmFkZCh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5hYmxlVHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BbmltYXRpb25zKCk7XG4gICAgfVxuICAgIF9kaXNhYmxlVHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuZW5kQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBfZ2V0U2Nyb2xsQW5jaG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIC8vIEFzayB0aGUgZGVsZWdhdGUgdG8gcHJvdmlkZSBhIHNjcm9sbCBhbmNob3IsIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmdldFNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxheW91dEluZm8ucmVjdFtjb3JuZXJdLnkgLSB2aXNpYmxlUmVjdC55O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIGFuY2hvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlmIGl0IGlzIGF0IHRoZSB0b3BcbiAgICAgICAgaWYgKHZpc2libGVSZWN0LnkgPT09IDAgJiYgIXRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZpbmQgYSB2aWV3IHdpdGggYSB2aXNpYmxlIGNvcm5lciB0aGF0IGhhcyB0aGUgc21hbGxlc3QgZGlzdGFuY2UgdG8gdGhlIHRvcCBvZiB0aGUgY29sbGVjdGlvbiB2aWV3XG4gICAgICAgIGxldCBjb3JuZXJBbmNob3IgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2aWV3XSBvZiB0aGlzLl92aXNpYmxlVmlld3Mpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mbyAmJiBsYXlvdXRJbmZvLnJlY3QuYXJlYSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyID0gbGF5b3V0SW5mby5yZWN0LmdldENvcm5lckluUmVjdCh2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGF5b3V0SW5mby5yZWN0W2Nvcm5lcl0ueSAtIHZpc2libGVSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29ybmVyQW5jaG9yIHx8IG9mZnNldCA8IGNvcm5lckFuY2hvci5vZmZzZXQpIGNvcm5lckFuY2hvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcm5lckFuY2hvcjtcbiAgICB9XG4gICAgX3Jlc3RvcmVTY3JvbGxBbmNob3Ioc2Nyb2xsQW5jaG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICBpZiAoc2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHRfdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBsZXQgZmluYWxBbmNob3IgPSAoKF9jb250ZXh0X3RyYW5zYWN0aW9uID0gY29udGV4dC50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2NvbnRleHRfdHJhbnNhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb250ZXh0X3RyYW5zYWN0aW9uLmFuaW1hdGVkKSA/IGNvbnRleHQudHJhbnNhY3Rpb24uZmluYWxNYXAuZ2V0KHNjcm9sbEFuY2hvci5rZXkpIDogdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhzY3JvbGxBbmNob3IubGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgaWYgKGZpbmFsQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdG1lbnQgPSBmaW5hbEFuY2hvci5yZWN0W3Njcm9sbEFuY2hvci5jb3JuZXJdLnkgLSBjb250ZW50T2Zmc2V0LnkgLSBzY3JvbGxBbmNob3Iub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQueSArPSBhZGp1c3RtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRWaXNpYmxlUmVjdCgpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLnZpc2libGVSZWN0O1xuICAgICAgICBsZXQgeCA9IHYueCAtIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xuICAgICAgICBsZXQgeSA9IHYueSAtIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55O1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoeCwgeSwgdi53aWR0aCwgdi5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXRWaXNpYmxlTGF5b3V0SW5mb3MoKSB7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5zaG91bGRPdmVyc2NhbiA/IHRoaXMuX292ZXJzY2FuTWFuYWdlci5nZXRPdmVyc2Nhbm5lZFJlY3QoKSA6IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcChyZWN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcztcbiAgICB9XG4gICAgX2dldExheW91dEluZm9NYXAocmVjdCwgY29weSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcbiAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXA7XG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGNvcHkpIGxheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCB2aXNpYmxlTGF5b3V0SW5mb3MgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcygpO1xuICAgICAgICBsZXQgY3VycmVudGx5VmlzaWJsZSA9IHRoaXMuX3Zpc2libGVWaWV3cztcbiAgICAgICAgbGV0IHRvQWRkLCB0b1JlbW92ZSwgdG9VcGRhdGU7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3JjZSB1cGRhdGUsIHJlbW92ZSBhbmQgcmUtYWRkIGFsbCB2aWV3cy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBmaW5kIGFuZCB1cGRhdGUgdGhlIGRpZmYuXG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgdG9BZGQgPSB2aXNpYmxlTGF5b3V0SW5mb3M7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IGN1cnJlbnRseVZpc2libGU7XG4gICAgICAgICAgICB0b1VwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICh7IHRvQWRkOiB0b0FkZCwgdG9SZW1vdmU6IHRvUmVtb3ZlLCB0b1VwZGF0ZTogdG9VcGRhdGUgfSA9ICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YikoY3VycmVudGx5VmlzaWJsZSwgdmlzaWJsZUxheW91dEluZm9zKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9VcGRhdGUpe1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcubGF5b3V0SW5mbykgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odmlzaWJsZUxheW91dEluZm9zLmdldChrZXkpLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuY29udGVudCA9PT0gaXRlbSkgdG9VcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2aWV3IHR5cGUgY2hhbmdlcywgZGVsZXRlIGFuZCByZWNyZWF0ZSB0aGUgdmlldyBpbnN0ZWFkIG9mIHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHJldXNlVHlwZTogcmV1c2VUeXBlIH0gPSB0aGlzLl9nZXRSZXVzZVR5cGUodmlldy5sYXlvdXRJbmZvLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcudmlld1R5cGUgIT09IHJldXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9VcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FkZC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgaWYgdGhlIHNldHMgYXJlIGVxdWFsXG4gICAgICAgICAgICBpZiAodG9BZGQuc2l6ZSA9PT0gMCAmJiB0b1JlbW92ZS5zaXplID09PSAwICYmIHRvVXBkYXRlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhY2sgdmlld3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC4gVGhleSBhcmUgbm90IHJlbW92ZWQgZnJvbVxuICAgICAgICAvLyB0aGUgRE9NIGltbWVkaWF0ZWx5LCBzaW5jZSB3ZSBtYXkgcmV1c2UgYW5kIG5lZWQgdG8gcmUtaW5zZXJ0XG4gICAgICAgIC8vIHRoZW0gYmFjayBpbnRvIHRoZSBET00gYW55d2F5LlxuICAgICAgICBsZXQgcmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvUmVtb3ZlLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5hZGQodmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgdHJhbnNhY3Rpb24sIHdhaXQgdW50aWwgdGhlIGVuZFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBhbmltYXRpb25zIHRvIHJlbW92ZSB0aGUgdmlld3MgZnJvbSB0aGUgRE9NLiBBbHNvIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgcmV1c2UgdGhvc2Ugdmlld3MgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucmV1c2VWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b0FkZC5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBsZXQgdmlldztcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgdHJhbnNhY3Rpb24sIGFuZCBhIGxheW91dCBjaGFuZ2UgaGFwcGVuc1xuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBhbmltYXRpb25zIHN1Y2ggdGhhdCBhIHZpZXcgdGhhdCB3YXMgZ29pbmdcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWQgaXMgbm93IG5vdCwgd2UgZG9uJ3QgY3JlYXRlIGEgbmV3IHZpZXdcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBvbGQgb25lIGlzIHN0aWxsIGluIHRoZSBET00sIG1hcmtlZCBhcyB0b1JlbW92ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRyYW5zYWN0aW9uLCBnZXQgaW5pdGlhbCBsYXlvdXQgYXR0cmlidXRlcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5oYXMoa2V5KSkgbGF5b3V0SW5mbyA9IHRoaXMuX3RyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBvciByZXVzZSBhIHZpZXcgZm9yIHRoaXMgcm93XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuZ2V0UmV1c2FibGVWaWV3KGxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmlldyB0byB0aGUgRE9NIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlZC5oYXModmlldykpIHRoaXMuX2NoaWxkcmVuLmFkZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IGN1cnJlbnRseVZpc2libGUuZ2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVtYWluaW5nIHJvd3MgdG8gZGVsZXRlIGZyb20gdGhlIERPTVxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLnJlbW92ZVZpZXdzKHJlbW92ZWQpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgICAgIGxldCBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy5fdHJhbnNhY3Rpb24gJiYgKHRvQWRkLnNpemUgPiAwIHx8IHRvUmVtb3ZlLnNpemUgPiAwIHx8IHRoaXMuX2hhc0xheW91dFVwZGF0ZXMoKSk7XG4gICAgICAgIGlmIChoYXNMYXlvdXRVcGRhdGVzKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgdHJhbnNhY3Rpb24sIGFwcGx5IGFuaW1hdGlvbnMgdG8gdmlzaWJsZSB2aWV3c1xuICAgICAgICAgICAgLy8gYW5kIFwidG8gYmUgcmVtb3ZlZFwiIHZpZXdzLCB3aGljaCBhbmltYXRlIG9mZiBzY3JlZW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYXNMYXlvdXRVcGRhdGVzO1xuICAgIH1cbiAgICBhZnRlclJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uUXVldWUubGVuZ3RoID4gMCkgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCkgdGhpcy5yZWxheW91dE5vdygpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRPdmVyc2NhbikgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLmNvbGxlY3RNZXRyaWNzKCk7XG4gICAgfVxuICAgIF9mbHVzaFZpc2libGVWaWV3cygpIHtcbiAgICAgICAgLy8gQ29sbGVjdGlvblZpcnR1YWxpemVyIGRlYWxzIHdpdGggYSBmbGF0dGVuZWQgc2V0IG9mIExheW91dEluZm9zLCBidXQgdGhleSBjYW4gcmVwcmVzZW50IGhpZXJhcmNoeVxuICAgICAgICAvLyBieSByZWZlcmVuY2luZyBhIHBhcmVudEtleS4gSnVzdCBiZWZvcmUgcmVuZGVyaW5nIHRoZSB2aXNpYmxlIHZpZXdzLCB3ZSByZWJ1aWxkIHRoaXMgaGllcmFyY2h5XG4gICAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgbWFwcGluZyBvZiB2aWV3cyBieSBwYXJlbnQga2V5IGFuZCByZWN1cnNpdmVseSBjYWxsaW5nIHRoZSBkZWxlZ2F0ZSdzIHJlbmRlcldyYXBwZXJcbiAgICAgICAgLy8gbWV0aG9kIHRvIGJ1aWxkIHRoZSBmaW5hbCB0cmVlLlxuICAgICAgICBsZXQgdmlld3NCeVBhcmVudEtleSA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fY2hpbGRyZW4pe1xuICAgICAgICAgICAgdmFyIF92aWV3X2xheW91dEluZm8sIF92aWV3c0J5UGFyZW50S2V5X2dldCwgX3ZpZXdfbGF5b3V0SW5mbzEsIF92aWV3X2xheW91dEluZm8yLCBfdmlld19sYXlvdXRJbmZvMztcbiAgICAgICAgICAgIGlmICgoKF92aWV3X2xheW91dEluZm8gPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8ucGFyZW50S2V5KSAhPSBudWxsICYmICF2aWV3c0J5UGFyZW50S2V5Lmhhcyh2aWV3LmxheW91dEluZm8ucGFyZW50S2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQodmlldy5sYXlvdXRJbmZvLnBhcmVudEtleSwgW10pO1xuICAgICAgICAgICAgKF92aWV3c0J5UGFyZW50S2V5X2dldCA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KChfdmlld19sYXlvdXRJbmZvMSA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8xLnBhcmVudEtleSkpID09PSBudWxsIHx8IF92aWV3c0J5UGFyZW50S2V5X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LnB1c2godmlldyk7XG4gICAgICAgICAgICBpZiAoIXZpZXdzQnlQYXJlbnRLZXkuaGFzKChfdmlld19sYXlvdXRJbmZvMiA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8yLmtleSkpIHZpZXdzQnlQYXJlbnRLZXkuc2V0KChfdmlld19sYXlvdXRJbmZvMyA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8zLmtleSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWlsZFRyZWUgPSAocGFyZW50LCB2aWV3cyk9PnZpZXdzLm1hcCgodmlldyk9PntcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB2aWV3c0J5UGFyZW50S2V5LmdldCh2aWV3LmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW5kZXJXcmFwcGVyKHBhcmVudCwgdmlldywgY2hpbGRyZW4sIChjaGlsZFZpZXdzKT0+YnVpbGRUcmVlKHZpZXcsIGNoaWxkVmlld3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBidWlsZFRyZWUobnVsbCwgdmlld3NCeVBhcmVudEtleS5nZXQobnVsbCkpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZpc2libGVWaWV3cyhjaGlsZHJlbik7XG4gICAgfVxuICAgIF9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykge1xuICAgICAgICBpZiAodmlldy5sYXlvdXRJbmZvID09PSBsYXlvdXRJbmZvKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcubGF5b3V0SW5mbyA9IGxheW91dEluZm87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfYXBwbHlMYXlvdXRJbmZvcygpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQXBwbHkgbGF5b3V0IGluZm9zIHRvIHZpc2libGUgdmlld3NcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmICgoY3VyID09PSBudWxsIHx8IGN1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBmaW5hbCBsYXlvdXQgaW5mb3MgZm9yIHZpZXdzIHRoYXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS52YWx1ZXMoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgICAgICBpZiAoKGN1ciA9PT0gbnVsbCB8fCBjdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ci5rZXkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3RyYW5zYWN0aW9uLnJlbW92ZWQudmFsdWVzKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uZ2V0KGN1ci5rZXkpIHx8IGN1cjtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0RmluYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCkgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICB9XG4gICAgX2hhc0xheW91dFVwZGF0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmICghY3VyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgIGlmICgvLyBVc2VzIGVxdWFscyByYXRoZXIgdGhhbiBwb2ludEVxdWFscyBzbyB0aGF0IHdpZHRoL2hlaWdodCBjaGFuZ2VzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICFjdXIucmVjdC5lcXVhbHMobGF5b3V0SW5mby5yZWN0KSB8fCBjdXIub3BhY2l0eSAhPT0gbGF5b3V0SW5mby5vcGFjaXR5IHx8IGN1ci50cmFuc2Zvcm0gIT09IGxheW91dEluZm8udHJhbnNmb3JtKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldXNlVmlldyh2aWV3KSB7XG4gICAgICAgIHZpZXcucHJlcGFyZUZvclJldXNlKCk7XG4gICAgICAgIHRoaXMuX3JldXNhYmxlVmlld3Nbdmlldy52aWV3VHlwZV0ucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmVtb3ZlVmlld3ModG9SZW1vdmUpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0b1JlbW92ZSl0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYmUgYWJsZSB0byBpbnZhbGlkYXRlIGEgc2luZ2xlIGluZGV4IHBhdGhcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0LnVwZGF0ZUl0ZW1TaXplKSByZXR1cm47XG4gICAgICAgIC8vIElmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgY3VycmVudGx5IGFuaW1hdGluZywgYWRkIHRoZSB1cGRhdGVcbiAgICAgICAgLy8gdG8gYSBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlLnNldChrZXksIHNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLmxheW91dC51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xuICAgICAgICBpZiAoY2hhbmdlZCkgdGhpcy5yZWxheW91dCgpO1xuICAgIH1cbiAgICBzdGFydFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBlbmRTY3JvbGxpbmcoKSB7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICB9XG4gICAgX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYW5pbWF0ZWQgY29udGVudCBvZmZzZXQgb2Ygc3Vidmlld3MuIFNlZSBjb21tZW50IGluIHJlbGF5b3V0Tm93IGZvciBkZXRhaWxzLlxuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogU2Nyb2xscyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXkgaW50byB2aWV3LCBvcHRpb25hbGx5IHdpdGggYW4gYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gc2Nyb2xsIGludG8gdmlldy5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICovIHNjcm9sbFRvSXRlbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgLy8ga2V5IGNhbiBiZSAwLCBzbyBjaGVjayBpZiBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgIGlmICghbGF5b3V0SW5mbykgcmV0dXJuO1xuICAgICAgICBsZXQgeyBkdXJhdGlvbjogZHVyYXRpb24gPSAzMDAsIHNob3VsZFNjcm9sbFg6IHNob3VsZFNjcm9sbFggPSB0cnVlLCBzaG91bGRTY3JvbGxZOiBzaG91bGRTY3JvbGxZID0gdHJ1ZSwgb2Zmc2V0WDogb2Zmc2V0WCA9IDAsIG9mZnNldFk6IG9mZnNldFkgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgeCA9IHRoaXMudmlzaWJsZVJlY3QueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIGxldCBtaW5YID0gbGF5b3V0SW5mby5yZWN0LnggLSBvZmZzZXRYO1xuICAgICAgICBsZXQgbWluWSA9IGxheW91dEluZm8ucmVjdC55IC0gb2Zmc2V0WTtcbiAgICAgICAgbGV0IG1heFggPSB4ICsgdGhpcy52aXNpYmxlUmVjdC53aWR0aDtcbiAgICAgICAgbGV0IG1heFkgPSB5ICsgdGhpcy52aXNpYmxlUmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGxYKSB7XG4gICAgICAgICAgICBpZiAobWluWCA8PSB4IHx8IG1heFggPT09IDApIHggPSBtaW5YO1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFggPiBtYXhYKSB4ICs9IGxheW91dEluZm8ucmVjdC5tYXhYIC0gbWF4WDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsWSkge1xuICAgICAgICAgICAgaWYgKG1pblkgPD0geSB8fCBtYXhZID09PSAwKSB5ID0gbWluWTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheW91dEluZm8ucmVjdC5tYXhZID4gbWF4WSkgeSArPSBsYXlvdXRJbmZvLnJlY3QubWF4WSAtIG1heFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8obmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSksIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGFuIGFuaW1hdGVkIHNjcm9sbCB0byB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCB0byBzY3JvbGwgdG8uXG4gICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKi8gc2Nyb2xsVG8ob2Zmc2V0LCBkdXJhdGlvbiA9IDMwMCkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgc2Nyb2xsIGFuaW1hdGlvblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgY29udGVudCBvZmZzZXQgc3luY2hyb25vdXNseSBpZiB0aGUgZHVyYXRpb24gaXMgemVyb1xuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMCB8fCB0aGlzLnZpc2libGVSZWN0LnBvaW50RXF1YWxzKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9ICgwLCAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYykodGhpcy52aXNpYmxlUmVjdCwgb2Zmc2V0LCBkdXJhdGlvbiwgKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwKSwgKG9mZnNldCk9PntcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi50aGVuKCgpPT57XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB2aWV3IHNpemUgdXBkYXRlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgICAgLy8gT25seSB2aWV3cyB0aGF0IGFyZSBzdGlsbCB2aXNpYmxlIHdpbGwgYmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHNpemVdIG9mIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSl0aGlzLnVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXlvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmVuZFNjcm9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEFuaW1hdGlvbjtcbiAgICB9XG4gICAgX3J1blRyYW5zYWN0aW9uKGFjdGlvbiwgYW5pbWF0ZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIHRoaXMuX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKTtcbiAgICB9XG4gICAgX3N0YXJ0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmV4dFRyYW5zYWN0aW9uKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBuZXcgKDAsICQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwKTtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmxldmVsKys7XG4gICAgfVxuICAgIF9lbmRUcmFuc2FjdGlvbihhbmltYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX25leHRUcmFuc2FjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBTYXZlIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhbmltYXRlZC5cbiAgICAgICAgaWYgKGFuaW1hdGVkICE9IG51bGwpIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9IGFuaW1hdGVkO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgbGV2ZWwgMCwgd2UgYXJlIHN0aWxsIGluIGFcbiAgICAgICAgLy8gbmVzdGVkIHRyYW5zYWN0aW9uLiBXYWl0IGZvciB0aGUgcGFyZW50IHRvIGVuZC5cbiAgICAgICAgaWYgKC0tdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmxldmVsID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciBlbXB0eSB0cmFuc2FjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGFuaW1hdGlvbnMgdG8gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID09IG51bGwpIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9IHRydWU7XG4gICAgICAgIC8vIEVucXVldWUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uUXVldWUucHVzaCh0aGlzLl9uZXh0VHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBpcyBhbmltYXRpbmcsIHdhaXQgdW50aWwgdGhlIGVuZFxuICAgICAgICAvLyB0byBwcm9jZXNzIHRoZSBuZXh0IHRyYW5zYWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24gfHwgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAobmV4dCkgdGhpcy5fcGVyZm9ybVRyYW5zYWN0aW9uKG5leHQpO1xuICAgIH1cbiAgICBfZ2V0Q29udGVudFJlY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSgwLCAwLCB0aGlzLmNvbnRlbnRTaXplLndpZHRoLCB0aGlzLmNvbnRlbnRTaXplLmhlaWdodCk7XG4gICAgfVxuICAgIF9wZXJmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5yZWxheW91dE5vdyh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhbmltYXRlZDogdHJhbnNhY3Rpb24uYW5pbWF0ZWQsXG4gICAgICAgICAgICBiZWZvcmVMYXlvdXQ6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbml0aWFsIGxheW91dCBpbmZvcyBmb3IgYWxsIHZpZXdzIGJlZm9yZSB0aGUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiBmaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHRvIGFkZCBhbmQgcmVtb3ZlLlxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hbmltYXRlZCkgdHJhbnNhY3Rpb24uaW5pdGlhbE1hcCA9IHRoaXMuX2dldExheW91dEluZm9NYXAodGhpcy5fZ2V0Q29udGVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGFjdGlvbnMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhpcyB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiB0cmFuc2FjdGlvbi5hY3Rpb25zKWFjdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyTGF5b3V0OiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbGF5b3V0IGluZm9zIGFmdGVyIHRoZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnModHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJBbmltYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFuZCByZXVzZSB2aWV3cyB3aGVuIGFuaW1hdGlvbnMgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24udG9SZW1vdmUuc2l6ZSA+IDAgfHwgdHJhbnNhY3Rpb24ucmVtb3ZlZC5zaXplID4gMCkgZm9yIChsZXQgdmlldyBvZiAoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYpKHRyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpLCB0cmFuc2FjdGlvbi5yZW1vdmVkLnZhbHVlcygpKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXVzZVZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgRE9NIG9yZGVyIGlzIGNvcnJlY3QgZm9yIGFjY2Vzc2liaWxpdHkgYWZ0ZXIgYW5pbWF0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGxldCB7IGluaXRpYWxNYXA6IGluaXRpYWxNYXAsIGZpbmFsTWFwOiBmaW5hbE1hcCB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgYW5kIGZpbmFsIGxheW91dCBpbmZvcyBmb3IgYW5pbWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBpbml0aWFsTWFwKWlmIChmaW5hbE1hcC5oYXMoa2V5KSkgLy8gU3RvcmUgdGhlIGluaXRpYWwgbGF5b3V0IGluZm8gZm9yIHVzZSBkdXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uc2V0KGtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIGVsc2UgLy8gVGhpcyB2aWV3IHdhcyByZW1vdmVkLiBTdG9yZSB0aGUgbGF5b3V0IGluZm8gZm9yIHVzZVxuICAgICAgICAvLyBpbiBMYXlvdXQjZ2V0RmluYWxMYXlvdXRJbmZvIGR1cmluZyBhbmltYXRpb25zLlxuICAgICAgICB0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uc2V0KGxheW91dEluZm8ua2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgLy8gR2V0IGluaXRpYWwgbGF5b3V0IGluZm9zIGZvciB2aWV3cyB0aGF0IHdlcmUgYWRkZWRcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbGF5b3V0SW5mb10gb2YgZmluYWxNYXApaWYgKCFpbml0aWFsTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvLmNvcHkoKSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBpbml0aWFsTGF5b3V0SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCB2aWV3cyB3ZXJlIHJlbW92ZWQuXG4gICAgICAgIGZvciAobGV0IFtrZXksIHZpZXddIG9mIHRoaXMuX3Zpc2libGVWaWV3cykvLyBJZiBhbiBpdGVtIGhhcyBhIHdpZHRoIG9mIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gdGhlIF92aXNpYmxlVmlld3MuXG4gICAgICAgIC8vIFJlbW92aW5nIGFuIGl0ZW0gd2l0aCAgd2lkdGggb2YgMCBjYW4gY2F1c2UgYSBsb29wIHdoZXJlIHRoZSBpdGVtIGdldHMgYWRkZWQsIHJlbW92ZWQsXG4gICAgICAgIC8vIGFkZGVkLCByZW1vdmVkLi4uIGV0YyBpbiBhIGxvb3AuXG4gICAgICAgIGlmICghZmluYWxNYXAuaGFzKGtleSkgJiYgdmlldy5sYXlvdXRJbmZvLnJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmVkLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBzb21ldGhpbmcgd2VpcmQgaGFwcGVuZWQsIHdoZXJlIHdlIGhhdmUgYSB2aWV3IGJ1dCBub1xuICAgICAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgaW5mbywgdXNlIHRoZSBvbmUgYXR0YWNoZWQgdG8gdGhlIHZpZXcuXG4gICAgICAgICAgICBpZiAodmlldy5sYXlvdXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uaGFzKHZpZXcubGF5b3V0SW5mby5rZXkpKSB0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uc2V0KHZpZXcubGF5b3V0SW5mby5rZXksIHZpZXcubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSBuZXcgKDAsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKTtcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3cyA9IHt9O1xuICAgICAgICB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIgPSBuZXcgKDAsICQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiKSgpO1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldCA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDAsIDApO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdmFyIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgLy8gU2V0IG9wdGlvbnMgZnJvbSBwYXNzZWQgb2JqZWN0IGlmIGdpdmVuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uID0gKF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gIT09IHZvaWQgMCA/IF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiA6IDUwMDtcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbiA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsUG9zaXRpb24gfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRPdmVyc2NhbiA9IG9wdGlvbnMuc2hvdWxkT3ZlcnNjYW4gIT09IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xuICAgICAgICAgICAgXCJkZWxlZ2F0ZVwiLFxuICAgICAgICAgICAgXCJzaXplXCIsXG4gICAgICAgICAgICBcImxheW91dFwiLFxuICAgICAgICAgICAgXCJjb2xsZWN0aW9uXCJcbiAgICAgICAgXSlpZiAob3B0aW9uc1trZXldKSB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uICRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1KG9wdHMpIHtcbiAgICBsZXQgW3Zpc2libGVWaWV3cywgc2V0VmlzaWJsZVZpZXdzXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKFtdKTtcbiAgICBsZXQgW2NvbnRlbnRTaXplLCBzZXRDb250ZW50U2l6ZV0gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShuZXcgKDAsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKSgpKTtcbiAgICBsZXQgW2lzQW5pbWF0aW5nLCBzZXRBbmltYXRpbmddID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBbaXNTY3JvbGxpbmcsIHNldFNjcm9sbGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHZpcnR1YWxpemVyID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMikoKSwgW10pO1xuICAgIHZpcnR1YWxpemVyLmRlbGVnYXRlID0ge1xuICAgICAgICBzZXRWaXNpYmxlVmlld3M6IHNldFZpc2libGVWaWV3cyxcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QgKHJlY3QpIHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgIG9wdHMub25WaXNpYmxlUmVjdENoYW5nZShyZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29udGVudFNpemU6IHNldENvbnRlbnRTaXplLFxuICAgICAgICByZW5kZXJWaWV3OiBvcHRzLnJlbmRlclZpZXcsXG4gICAgICAgIHJlbmRlcldyYXBwZXI6IG9wdHMucmVuZGVyV3JhcHBlcixcbiAgICAgICAgYmVnaW5BbmltYXRpb25zOiAoKT0+c2V0QW5pbWF0aW5nKHRydWUpLFxuICAgICAgICBlbmRBbmltYXRpb25zOiAoKT0+c2V0QW5pbWF0aW5nKGZhbHNlKSxcbiAgICAgICAgZ2V0U2Nyb2xsQW5jaG9yOiBvcHRzLmdldFNjcm9sbEFuY2hvclxuICAgIH07XG4gICAgdmlydHVhbGl6ZXIubGF5b3V0ID0gb3B0cy5sYXlvdXQ7XG4gICAgdmlydHVhbGl6ZXIuY29sbGVjdGlvbiA9IG9wdHMuY29sbGVjdGlvbjtcbiAgICB2aXJ0dWFsaXplci50cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAoMCwgJDhEM25yJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuYWZ0ZXJSZW5kZXIoKTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkOEQzbnIkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PnZpcnR1YWxpemVyLndpbGxVbm1vdW50KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtdKTtcbiAgICBsZXQgc2V0VmlzaWJsZVJlY3QgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgocmVjdCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgc3RhcnRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5zdGFydFNjcm9sbGluZygpO1xuICAgICAgICBzZXRTY3JvbGxpbmcodHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBlbmRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5lbmRTY3JvbGxpbmcoKTtcbiAgICAgICAgc2V0U2Nyb2xsaW5nKGZhbHNlKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IHN0YXRlID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyOiB2aXJ0dWFsaXplcixcbiAgICAgICAgICAgIHZpc2libGVWaWV3czogdmlzaWJsZVZpZXdzLFxuICAgICAgICAgICAgc2V0VmlzaWJsZVJlY3Q6IHNldFZpc2libGVSZWN0LFxuICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLFxuICAgICAgICAgICAgaXNBbmltYXRpbmc6IGlzQW5pbWF0aW5nLFxuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IGlzU2Nyb2xsaW5nLFxuICAgICAgICAgICAgc3RhcnRTY3JvbGxpbmc6IHN0YXJ0U2Nyb2xsaW5nLFxuICAgICAgICAgICAgZW5kU2Nyb2xsaW5nOiBlbmRTY3JvbGxpbmdcbiAgICAgICAgfSksIFtcbiAgICAgICAgdmlydHVhbGl6ZXIsXG4gICAgICAgIHZpc2libGVWaWV3cyxcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QsXG4gICAgICAgIGNvbnRlbnRTaXplLFxuICAgICAgICBpc0FuaW1hdGluZyxcbiAgICAgICAgaXNTY3JvbGxpbmcsXG4gICAgICAgIHN0YXJ0U2Nyb2xsaW5nLFxuICAgICAgICBlbmRTY3JvbGxpbmdcbiAgICBdKTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5cblxuXG5cbmV4cG9ydCB7JGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSBhcyBMYXlvdXQsICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IGFzIExheW91dEluZm8sICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIGFzIFBvaW50LCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCBhcyBSZWN0LCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyBhcyBTaXplLCAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSBhcyBSZXVzYWJsZVZpZXcsICRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1IGFzIHVzZVZpcnR1YWxpemVyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;